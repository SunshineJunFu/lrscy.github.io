{"meta":{"title":"Meow","subtitle":null,"description":null,"author":"Meow","url":"https://lrscy.github.io"},"pages":[{"title":"","date":"2018-01-24T03:47:57.062Z","updated":"2018-01-24T03:47:57.058Z","comments":false,"path":"tags/index.html","permalink":"https://lrscy.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2018-01-24T03:48:19.514Z","updated":"2018-01-24T03:48:19.510Z","comments":false,"path":"categories/index.html","permalink":"https://lrscy.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Cocos2d-x v3.16 Y轴翻转","slug":"Cocos2dx-3-16-Y-axis-Flip","date":"2018-02-11T12:42:15.000Z","updated":"2018-02-11T13:51:50.435Z","comments":true,"path":"2018/02/11/Cocos2dx-3-16-Y-axis-Flip/","link":"","permalink":"https://lrscy.github.io/2018/02/11/Cocos2dx-3-16-Y-axis-Flip/","excerpt":"","text":"Cocos2d-x的设计中，setPosition等的原点是在屏幕左下角，但是当把触摸点坐标转换到屏幕坐标点时发现其原点在左上角。这样设计的好处是自然的支持纵向的“自然滚动”（即向下划的时候上面的内容自然出现，反之亦然）。然而当不需要这个功能的时候，会在坐标变换上小折腾下。 由于在处理多点触碰和缩放时候这个坐标转换耗费了不少的时间，为了以后懒得在这个上面再费时间和脑力（就是懒emmmm），归纳一点：“旧纵坐标减新纵坐标”。今后再有类似问题就来看着这条改下就好了。","categories":[{"name":"Cocos2d-x","slug":"Cocos2d-x","permalink":"https://lrscy.github.io/categories/Cocos2d-x/"}],"tags":[{"name":"Cocos2d-x","slug":"Cocos2d-x","permalink":"https://lrscy.github.io/tags/Cocos2d-x/"},{"name":"Axis","slug":"Axis","permalink":"https://lrscy.github.io/tags/Axis/"}]},{"title":"Cocos2dx-3.16-Android-Multi-Touch","slug":"Cocos2dx-3-16-Android-Multi-Touch","date":"2018-02-11T12:40:58.000Z","updated":"2018-02-11T14:06:12.635Z","comments":true,"path":"2018/02/11/Cocos2dx-3-16-Android-Multi-Touch/","link":"","permalink":"https://lrscy.github.io/2018/02/11/Cocos2dx-3-16-Android-Multi-Touch/","excerpt":"","text":"网上有关Cocos2d-x v3.x版本的多点触控的资料并不多，在尝试时发现了如下几个坑。跳出坑最好的办法就是去读官方给出的Testapp的源码，这样能看快的了解到官方时如何使用各种功能的，模仿和学起来都很快且很到位。如果更有能力的去多看看API和源码也是很好的学习途径。 onTouchesBegan/Moved/Ended/Cancelled函数的参数网上众多教程基本都是基于2.x版本，所用函数名及参数有许多为cc开头，且触摸回调函数的参数基本为：12void MoreTouches::ccTouchesMoved( cocos2d::CCSet *pTouches, cocos2d::CCEvent *pEvent ); 在当前3.16版本中，其改为了12void onTouchesBegan( const std::vector&lt;cocos2d::Touch *&gt; &amp;touches, cocos2d::Event *event ); 不再使用set作为触摸点的存储结构，而是采用vector。 onTouchesBegan传入参数touches的问题开始参考网上多点触控的代码进行实验，但是在onTouchesBegan回调函数上永远出问题，后来发现onTouchesBegan回调函数的touches参数永远只存了一个变量（那你用vector存什么呀啊喂！）。在进行了众多测试以及上网寻找资料（不小心还挖了个坟emmmm）后决定仔细研究下官方的Testapp源码。 原先模仿网上函数写法的代码：1234void Hello::onTouchesBegan( const std::vector&lt;cocos2d::Touch *&gt; &amp;touches, cocos2d::Event *event ) &#123; if( touches.size() &gt;= 2 ) &#123; ... &#125; else &#123; ... &#125; 这段代码的touches.size()的值永远是1。官方给出的MultiTouch的源代码部分如下：123456static Map&lt;int, TouchPoint *&gt; s_map;void MultiTouchTest::onTouchesBegan( const std::vector&lt;Touch *&gt; &amp;touches, Event *event ) &#123; for ( auto &amp;item: touches ) &#123; ... &#125;&#125; 最开始看代码的时候还一脸欢喜，这官方给的例子不是明显的在说touches里面会存多变量的么。直到我用log打出来touches.size()后才“惊喜”的发现这值也是1（那你用vector干嘛呢遍历啥呢啊喂！）。 目前反推onTouchesBegan的设计逻辑是说一个指头的触摸激活一次onTouchesBegan，每个触摸的初始化单独做一次。这样的好处在于当多指相差时间很长才都按到屏幕上时，也能可以通过设计逻辑很容易的将其识别为多指操作，而不是多次单指操作。就算真的物理上是同时按住的时候也可能会给序列化处理成先后两次触摸。唯独麻烦的一点就是程序逻辑设计上要费点心思了。","categories":[{"name":"Cocos2d-x","slug":"Cocos2d-x","permalink":"https://lrscy.github.io/categories/Cocos2d-x/"}],"tags":[{"name":"Cocos2d-x","slug":"Cocos2d-x","permalink":"https://lrscy.github.io/tags/Cocos2d-x/"},{"name":"Android","slug":"Android","permalink":"https://lrscy.github.io/tags/Android/"},{"name":"Multi Touch","slug":"Multi-Touch","permalink":"https://lrscy.github.io/tags/Multi-Touch/"}]},{"title":"Cocos2d-x v3.16 Android Studio添加新类","slug":"Cocos2dx-3-16-Android-Studio-Add-New-Class","date":"2018-02-03T12:29:01.000Z","updated":"2018-02-11T13:56:58.662Z","comments":true,"path":"2018/02/03/Cocos2dx-3-16-Android-Studio-Add-New-Class/","link":"","permalink":"https://lrscy.github.io/2018/02/03/Cocos2dx-3-16-Android-Studio-Add-New-Class/","excerpt":"","text":"在使用Android Studio编辑Cocos2d-x项目时，如果想添加一个Class进去，除了建立相对应的.h和.cpp以外，还需要让编译配置文件知道这个文件属于该项目。然而Android Studio 3.x版本自动同步时并不能将新类中的.cpp问家加入编译配置文件中。 后来发现在左侧External Build Files中，有个叫做Android.mk的文件，需要在其中的LOCAL_SRC_FILES变量中加入新的.cpp文件。即：1234LOCAL_SRC_FILES := $(LOCAL_PATH)/hellocpp/main.cpp \\ $(LOCAL_PATH)/../../../Classes/AppDelegate.cpp \\ $(LOCAL_PATH)/../../../Classes/HelloWorldScene.cpp \\ $(LOCAL_PATH)/../../../Classes/Hello.cpp 想必大家都读得懂怎么向这个变量中加入新的文件，其中Hello.cpp就是我添加的新.cpp文件。","categories":[{"name":"Cocos2d-x","slug":"Cocos2d-x","permalink":"https://lrscy.github.io/categories/Cocos2d-x/"}],"tags":[{"name":"Cocos2d-x","slug":"Cocos2d-x","permalink":"https://lrscy.github.io/tags/Cocos2d-x/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"https://lrscy.github.io/tags/Android-Studio/"}]},{"title":"Ubuntu 16.04下TensorFlow安装","slug":"Ubuntu-Tensorflow-config","date":"2018-02-02T05:29:40.000Z","updated":"2018-02-02T10:46:53.572Z","comments":true,"path":"2018/02/02/Ubuntu-Tensorflow-config/","link":"","permalink":"https://lrscy.github.io/2018/02/02/Ubuntu-Tensorflow-config/","excerpt":"","text":"前言TensorFlow安装环境为Ubuntu 16.04.3 LTS，GPU为GT 750M。 假设目前已经安装好了CUDA8，如果没有安装请依照「Ubuntu 16.04下CUDA Tookit 8安装」进行安装。 如果有一定英语能力的同学最好请移步官网进行下载安装，尽管可能需要下科学上网。 基础环境搭建本文采用Virtualenv环境进行搭建，这样能将TensorFlow运行于一个分离开的Python环境下，免得今后出错时对整个系统产生影响。 CUPTI环境搭建CUPTI库能够提高可以提高CUDA的性能，官方要求安装。 如果CUDA Tookit &gt;= 8.0，输入如下命令安装：1$ sudo apt install cuda-command-line-tools 并且在CUDA安装时所设定的LD_LIBRARY_PATH添加路径至如下状态：1export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda/extras/CUPTI/lib64 如果CUDA Tookit &lt;= 7.5或者上述命令无法执行，请输入如下命令安装CUPTI库：1$ sudo apt-get install libcupti-dev pip环境搭建下面两行中选择一行执行即可，依据个人Python版本选择：12$ sudo apt install python-pip python-dev python-virtualenv # for Python 2.7$ sudo apt install python3-pip python3-dev python-virtualenv # for Python 3.x 本人选择的是Python2.7，因为Ubuntu 16.04.3默认Python为Python 2.7，改默认会影响ibus-pinyin（输入法）的更新和运行。 Virtualenv环境搭建下面两行中选择一行执行即可，依据个人Python版本选择：12$ virtualenv --system-site-packages targetDirectory # for Python 2.7$ virtualenv --system-site-packages -p python3 targetDirectory # for Python 3.x 其中targetDirectory是隔离环境的根目录，需要自行设定。个人设定是~/tensorflow，下文暂且按照这个目录进行介绍。 至此，基础观景搭建完成。 TensorFlow安装进入Virtualenv环境输入如下命令进入Virtualenv环境：12$ source ~/tensorflow/bin/activate # bash, sh, ksh, or zsh$ source ~/tensorflow/bin/activate.csh # csh or tcsh 请依据自身shell环境选择，一般Ubuntu原生使用的是sh。 这里可以在~/.bashrc中输入如下命令使得命令简化：12alias tensorflow=\"source ~/tensorflow/bin/activate\" # bash, sh, ksh, or zshalias tensorflow=\"source ~/tensorflow/bin/activate.csh\" # csh or tcsh 请依据自身的shell环境选择第一条还是第二条。其中tensorflow可以自行拟定。 当编辑完后在命令行中输入如下命令使其立即生效：1$ source ~/.bashrc 以后在命令行中输入tensorflow即可调出该Virtualenv环境。 当前环境应该如下：1(tensorflow) xxx@xxx:path$ tensorflow即Virtualenv文件夹名称，下文按照tensorflow描述。 xxx@xxx:path与未进入Virtualenv环境时无差别。下文中将简化描述为(tensorflow) $ 更新pip为了确保pip version &gt;= 8.1，输入如下命令更新pip：12(tensorflow) $ pip install --upgrade pip # for Python 2.7(tensorflow) $ pip3 install --upgrade pip # for Python 3.x 安装TensorFlow如果系统中的CUDA Tookit和cuDNN都是最新版，请从以下四条命令中选择一个来安装TensorFlow：1234(tensorflow) $ pip install --upgrade tensorflow # for Python 2.7(tensorflow) $ pip3 install --upgrade tensorflow # for Python 3.x(tensorflow) $ pip install --upgrade tensorflow-gpu # for Python 2.7 and GPU(tensorflow) $ pip3 install --upgrade tensorflow-gpu # for Python 3.x and GPU 前两条是仅使用CPU的版本，后两条的版本能够使用GPU。 如果系统中的CUDA Tookit和cuDNN并非最新版，按照上述安装很可能会出现问题导致重装。因此安装前请先完成如下几步： 请先确定系统中的cuDNN和CUDA Tookit时想匹配的，具体版本匹配详见官网。 请在TensorFlow的Github Release中寻找符合自己CUDA Tookit和cuDNN的版本。 依照选好的版本拼凑网址。 拼凑网址如下，请依据CPU以及GPU从两条中选择一条：1234# for CPU onlyhttps://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-x.x.x-cpxx-none-linux_x86_64.whl# for GPU supporthttps://storage.googleapis.com/tensorflow/linux/gpu/tensorflow_gpu-x.x.x-cpxx-none-linux_x86_64.whl 其中： x.x.x是从release中选择出的需要的版本。 cpxx是本机python的版本，例如：2.7.xx为27，3.5.xx的版本为35，以此类推。 storage.googleapis.com可能需要科学上网才能访问。 然后进行Tensorflow的安装，输入如下命令：12(tensorflow) $ pip install yourhttpsite # for Python 2.7(tensorflow) $ pip3 install yourhttpsite # for Python 3.x yourhttpsite就是拼凑出来的网址。 如果pip提示无法从代理处下载文件，则可以先将文件从网址下载下来并存在~（即家目录）或者自定义目录下，然后通过如下命令安装：12(tensorflow) $ pip install filename # for Python 2.7(tensorflow) $ pip3 install filename # for Python 3.x filename即下载的.whl文件（可能需要输入完整路径）。 TensorFlow的使用启动TensorFlow环境请参照进入Virtualenv环境步骤进行。 测试TensorFlow环境先进入TensorFlow环境，然后输入如下代码进行测试：1234import tensorflow as tfhello = tf.constant('Hello, TensorFlow!')sess = tf.Session()print(sess.run(hello)) 输出Hello, TensorFlow!且无报错即可。如果报错请参考官网或者上网寻找解决方案。 退出TensorFlow环境在环境中输入deactivate即可，即：1(tensorflow) $ deactivate TensorFlow的卸载卸载时直接将其所在的Virtualenv文件夹删除即可，命令如下：1$ rm -rf targetDirectory targetDirectory即Virtualenv环境文件夹。","categories":[{"name":"Config","slug":"Config","permalink":"https://lrscy.github.io/categories/Config/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://lrscy.github.io/tags/Ubuntu/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"https://lrscy.github.io/tags/Tensorflow/"}]},{"title":"Ubuntu 16.04下CUDA Tookit 8安装","slug":"Ubuntu-CUDA-Tookit-8-Install","date":"2018-02-01T03:39:17.000Z","updated":"2018-02-03T04:26:07.011Z","comments":true,"path":"2018/02/01/Ubuntu-CUDA-Tookit-8-Install/","link":"","permalink":"https://lrscy.github.io/2018/02/01/Ubuntu-CUDA-Tookit-8-Install/","excerpt":"","text":"前言前一阵重做系统把之前的安装教程的博客给弄丢了，现在重写一份做记录好了。目前老环境还是要CUDA Tookit 8（以下简称CUDA8），因此目前先不安装CUDA最新的CUDA9了。 本教程是在Ubuntu 16.04.3 LTS上进行的，其他版本的Ubuntu系统请自行实验，目前在Ubuntu 17.10系统上实验成功。 当前假设Ubuntu系统已经安装完成，目前直接进行CUDA8的安装。 基础准备基础环境安装安装CUDA8需要基础的编译环境，需要检测下系统上是否安装了gcc或g++。命令如下：12$ gcc -v$ g++ -v 如果任意一个出现版本信息就代表安装过了。如果都没有出现版本信息，则请采用如下命令安装：1$ sudo apt install build-essential 安装完成即可，网上有说CUDA8不支持g++ 5.0以上的版本，目前本人没有遇上这个问题。 附加环境安装有些人在上述基础环境下安装完CUDA8后会出现Missing recommended library: libGLU.so的提示。如果不确定当前环境想提前避免这个问题，请安装如下包：1sudo apt install libglu1-mesa libxi-dev libxmu-dev libglu1-mesa-dev 至此，基础环境都安装完了。 NVIDIA驱动安装个人强烈建议先装NVIDIA驱动，因为CUDA8自带的驱动实在是容易出问题。驱动安装详见「Ubuntu系统NVIDIA显卡驱动安装」。 CUDA8安装配置CUDA8下载先从官网下载CUDA的驱动。目前CUDA的最新版本是CUDA9，要下老版本的话请采用如下官方网址，下载Base Installer和Patch 2。 个人建议先将文件都下载到家目录(~)底下，因为如果系统是中文环境的话，后续安装可能会出现文件夹名乱码的情况。安装完成后可以移动到自己想移动的位置。 CUDA8安装是否进入tty1环境看个人，本人之前各种重装驱动给吓怕了，不确定图形界面是否影响到了，因此直接进入了tty1环境进行CUDA8的安装。关闭图形界面的步骤如下： 首先按住Ctrl+Alt+F1进入tty1 输入用户名和密码 执行sudo service lightdm stop命令关闭图形界面。 然后在安装文件所在目录下执行如下命令安装：12$ sudo chmod 755 (CUDA Install File)$ sudo ./(CUDA Install File) 其中CUDA Install File是个人CUDA安装文件的名字（包括文件后缀）。 安装关键过程如下（先后顺序记不清了）： 安装过程中先阅读完一大串协议，按住d往下（这样跳得很快），直到最后。然后输入accept。 会询问是否安装NVIDIA DRIVER，输入n。 询问是否安装OPENGL时输入n。（记得有这个问题的，这里是个大坑！！） 其他默认选择y或者空着（就是直接按回车）就行。 到最后可能会出现INCOMPLETE INSTALL，这里不用管。这是因为你没装它的驱动而已。如果出现Missing recommended library: libGLU.so的提示，请参考附加环境安装 等一切都安装好后重启即可。 补丁安装是否进入tty1环境依旧看个人，具体参考上一节开头。 安装时执行如下命令安装：12$ sudo chmod 755 (CUDA Patch File)$ sudo ./(CUDA Patch File) 其中CUDA Patch File是之前下载的CUDA8的补丁文件Patch 2。安装过程和前一节类似，基本上直接一路默认就行。 等一切安装完了后重启即可。 环境设置个人习惯在/etc/profile.d下设置环境变量。先进入该文件夹，然后执行如下命令：12$ sudo touch cuda.sh$ sudo vim cuda.sh 这里vim可以换成gedit或者其他熟悉的编辑器。如果不熟悉vim的同学无意间进去了，输入:q退出vim。 在编辑器中输入如下文字：123export CUDA_HOME=/usr/local/cuda-8.0export PATH=$PATH:/usr/local/cuda-8.0/binexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda-8.0/lib64 然后保存重启即可。 cuDNN安装cuDNN是个GPU加速库，能为深度学习网络的计算加速。在官网下载。下载前可能需要先注册NVIDIA DEVELOPER。注册过程很简单，注册完成后选择支持CUDA8.0的cuDNN下载即可。 在下载目录解压后进入cuda文件夹，这里会见到include和lib64两个文件夹。这里建议在命令行下执行，因为会用到sudo进行暂时的root权限申请。输入如下命令进行安装：12$ sudo cp include/cudnn.h /usr/local/cuda/include$ sudo cp lib64/libcudnn* /usr/local/cuda/lib64 然后进入/usr/local/cuda/lib64文件夹中，执行如下命令：1234$ sudo rm libcudnn.so libcudnn.so.6$ sudo ln -s libcudnn.so.6.0.20 libcudnn.so.6$ sudo ln -s libcudnn.so.6 libcudnn.so$ sudo ldconfig 这里.6和.6.0.20是下载的cuDNN的版本号，请依据个人下载的实际版本进行修改。 至此，cuDNN已经安装完成。 结尾至此，整个CUDA Tookit 8的所有安装过程就完成了。","categories":[{"name":"Config","slug":"Config","permalink":"https://lrscy.github.io/categories/Config/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://lrscy.github.io/tags/Ubuntu/"},{"name":"CUDA","slug":"CUDA","permalink":"https://lrscy.github.io/tags/CUDA/"}]},{"title":"Cocos2d-x v3.16 屏幕显示偏移","slug":"Cocos2dx-3-16-Display-Offset","date":"2018-01-26T12:28:36.000Z","updated":"2018-02-11T13:56:47.978Z","comments":true,"path":"2018/01/26/Cocos2dx-3-16-Display-Offset/","link":"","permalink":"https://lrscy.github.io/2018/01/26/Cocos2dx-3-16-Display-Offset/","excerpt":"","text":"在v3.16前，屏幕上显示Sprites, Nodes都是直接使用Director类获取可视区大小并直接在上面定位Nodes的，例如：123auto size = Director::getInstance()-&gt;getVisibleSize();auto sprite = Sprite::create( \"HelloWorld.png\" );sprite.setPosition( size.width / 2, size.height / 2 ); 目前不知道时从哪个版本开始的，直接使用上述代码会导致sprite下偏移(沿y轴)一定量但无左右偏移(沿x轴)。查找资料未果后看Helloworld样例，发现其用到了Director类中另一个变量纠正这个问题：1Vec2 origin = Director::getInstance()-&gt;getVisibleOrigin(); 这里origin是真正的屏幕左下角的位置，所有屏幕上的显示的图像都要依据这个坐标进行调整。也就是说上述代码要改成：1234auto size = Director::getInstance()-&gt;getVisibleSize();Vec2 origin = Director::getInstance()-&gt;getVisibleOrigin();auto sprite = Sprite::create( \"HelloWorld.png\" );sprite.setPosition( origin.x + size.width / 2, origin.y + size.height / 2 ); 这时，屏幕偏移问题解决了，sprite也在屏幕的真正的正中央。","categories":[{"name":"Cocos2d-x","slug":"Cocos2d-x","permalink":"https://lrscy.github.io/categories/Cocos2d-x/"}],"tags":[{"name":"Cocos2d-x","slug":"Cocos2d-x","permalink":"https://lrscy.github.io/tags/Cocos2d-x/"},{"name":"Display Offset","slug":"Display-Offset","permalink":"https://lrscy.github.io/tags/Display-Offset/"}]},{"title":"Cocos2d-x v3.16踩过的坑","slug":"Cocos2dx-3-16-Problems","date":"2018-01-26T08:35:23.000Z","updated":"2018-02-11T13:58:01.623Z","comments":true,"path":"2018/01/26/Cocos2dx-3-16-Problems/","link":"","permalink":"https://lrscy.github.io/2018/01/26/Cocos2dx-3-16-Problems/","excerpt":"","text":"前言最近刚碰关于Cocos2d-x的知识，也上网查过很多资料，但是很少有讲最新v3.16的博客。因此在此记录下使用v3.16时候遇上的坑。且会不定期更新该篇博客。 UPDATE 2018.02.11:之前是写在一起的，但是看起来太乱，就拆分到各自单独篇章中去了，这里只做个目录。 屏幕显示偏移 Android Studio添加新类 多点触控 Y轴翻转 To be continue…","categories":[{"name":"Cocos2d-x","slug":"Cocos2d-x","permalink":"https://lrscy.github.io/categories/Cocos2d-x/"}],"tags":[{"name":"Cocos2d-x","slug":"Cocos2d-x","permalink":"https://lrscy.github.io/tags/Cocos2d-x/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"https://lrscy.github.io/tags/Android-Studio/"}]},{"title":"在Github上备份Hexo博客","slug":"Hexo-Github-Backup","date":"2018-01-26T04:57:56.000Z","updated":"2018-02-03T04:25:38.939Z","comments":true,"path":"2018/01/26/Hexo-Github-Backup/","link":"","permalink":"https://lrscy.github.io/2018/01/26/Hexo-Github-Backup/","excerpt":"","text":"前言由于之前忘记备份Hexo博客的markdown文件，在重做系统时候还忘记备份博客了，导致现在不得不重新从网页上扒下来之前的文章重新写一遍，十分耗费精力。因此在网上找了下如何备份Hexo博客，在此记录下。 目前假设Git和Github环境已经配置好了，如果没有配置好详见「Ubuntu16.04下Github配置」。Git相关操作请参考廖雪峰的Git教程。 备份博客目前假设本地Hexo博客已经初始化，如果没有配置好Hexo博客详见「Ubuntu16.04下从零起步搭建配置github.io博客————Hexo」。 创建新分支在Github.io上建立博客时已经开了一个新仓库了，如果再开另一个仓库存放源代码有点浪费，因此采用建立新分支的方法备份博客。 虽然理论上什么时候创建新分支来备份都可以，但是还是建议在建立博客的时候就创建备份分支。（然而我中途才想起来-.-） 本地Git建立新分支命令如下：1$ git checkout -b BRANCHNAME BRANCHNAME是自定义的新分支的名字，建议起为hexo。 建立.gitignore建立.gitignore文件将不需要备份的文件屏蔽。个人的.gitignore文件如下：1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ 在Github上备份通过如下命令将本地文件备份到Github上。 假设目前在hexo博客的根目录下。123$ git add .$ git commit -m \"Backup\"$ git push origin hexo 这样就备份完博客了且在Github上能看到两个分支(master和hexo)。 设置默认分支在Github上你的github.io仓库中设置默认分支为hexo。这样有助于之后恢复博客。master分支时默认的博客静态页面分支，在之后恢复博客的时候并不需要。 个人备份习惯个人而言习惯于先备份文件再生成博客。即先执行git add .,git commit -m &quot;Backup&quot;,git push origin hexo将博客备份完成，然后执行hexo g -d发布博客。 恢复博客目前假设本地Hexo博客基础环境已经搭好，如果没有配置好Hexo博客基础环境详见「Ubuntu16.04下从零起步搭建配置github.io博客————Hexo」。 克隆项目到本地输入下列命令克隆博客必须文件(hexo分支)：1$ git clone https://github.com/yourgithubname/yourgithubname.github.io 恢复博客在克隆的那个文件夹下输入如下命令恢复博客：123$ npm install hexo$ npm install$ npm install hexo-deployer-git 在此不需要执行hexo init这条指令，因为不是从零搭建起新博客。 完成喵～","categories":[{"name":"Config","slug":"Config","permalink":"https://lrscy.github.io/categories/Config/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://lrscy.github.io/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"https://lrscy.github.io/tags/Github/"}]},{"title":"Hexo中图片插入问题","slug":"Hexo-Picture-Insert","date":"2018-01-26T01:59:05.000Z","updated":"2018-02-03T04:25:47.123Z","comments":true,"path":"2018/01/26/Hexo-Picture-Insert/","link":"","permalink":"https://lrscy.github.io/2018/01/26/Hexo-Picture-Insert/","excerpt":"","text":"前言在用Hexo搭建博客时有时需要插入图片，但是原生Hexo对图片管理的支持不是很好。此篇博客记录利用插件和Hexo的配置解决这个问题。 _config.yml配置更改在Hexo根目录下，_config.yml文件管理整个Hexo的配置设置。其中要开启post_asset_folder，即：1post_asset_folder: true 更改完成后，每新生成一片文章，就会在同级目录下生成一个名字相同的相对应的文件夹。图片存在该文件夹下即可。 安装插件由于原生Hexo资源文件夹在生成真正博客时地址转换有问题，需要安装插件进行修正。执行如下命令安装插件：1$ npm install https://github.com/CodeFalling/hexo-asset-image --save 当安装完成后就可以在写Markdown时很容易的使用资源文件夹下的图片了。 使用教程在插入图片时只要使用如下Markdown语法即可1![](文章名字/图片名字.后缀) 不知道我是不是因为在_config.yml中开启了relative_link，我采用如下方式插入图片：1![](图片名字.后缀) 这点以后再探究好了喵～","categories":[{"name":"Config","slug":"Config","permalink":"https://lrscy.github.io/categories/Config/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://lrscy.github.io/tags/Hexo/"},{"name":"Markdown","slug":"Markdown","permalink":"https://lrscy.github.io/tags/Markdown/"}]},{"title":"Markdown中MathJax的用法","slug":"Markdown-MathJax-Usage","date":"2018-01-26T01:25:33.000Z","updated":"2018-02-03T04:25:52.803Z","comments":true,"path":"2018/01/26/Markdown-MathJax-Usage/","link":"","permalink":"https://lrscy.github.io/2018/01/26/Markdown-MathJax-Usage/","excerpt":"","text":"前言Markdown和MathJax在一些语法上有交集，在此记录下两者有冲突的地方，作为今后的提醒。 下划线在Markdwon中，下划线代表斜体，例如：_a_的效果既是a。在MathJax中，下划线代表下标，例如：`$a\\_2$’的效果既是$a_2$。 在Markdown解析过程中，可能会出现错误解析MathJax下划线的事情。因此在MathJax公式中要将_替换成\\_，将下划线转义成真正的下划线符号。 多行公式在MathJax中，\\\\代表换行。在Markdown中，\\\\代表将转义字符\\转义成真正的\\字符，因此写\\\\后被解析出来时只有一个\\，因此无法达成换行效果。因此在写换行时连续输入三个\\即\\\\\\即可达成换行要求。例如：12345\\begin&#123;align&#125;r\\_t &amp;= \\sigma(W\\_rx\\_t + Urh\\_&#123;t-1&#125; + b\\_r) \\\\\\u\\_t &amp;= \\sigma(W\\_ux\\_t + r\\_t \\odot (U\\_uh\\_&#123;t-1&#125;) + b\\_u) \\\\\\h\\_t &amp;= u\\_t \\odot h\\_&#123;t-1&#125; + (1-u\\_t) \\odot \\tanh(Wx\\_t + r\\_t \\odot (U\\_uh\\_&#123;t-1&#125;) + b)\\end&#123;align&#125; 执行结果如下： $$\\begin{align}r_t &amp;= \\sigma(W_rx_t + Urh_{t-1} + b_r) \\\\u_t &amp;= \\sigma(W_ux_t + r_t \\odot (U_uh_{t-1}) + b_u) \\\\h_t &amp;= u_t \\odot h_{t-1} + (1-u_t) \\odot \\tanh(Wx_t + r_t \\odot (U_uh_{t-1}) + b)\\end{align}$$ 目前只踩到了这些坑，今后再有新坑再往后填入。","categories":[{"name":"Usage","slug":"Usage","permalink":"https://lrscy.github.io/categories/Usage/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://lrscy.github.io/tags/Markdown/"},{"name":"MathJax","slug":"MathJax","permalink":"https://lrscy.github.io/tags/MathJax/"}]},{"title":"Ubuntu 16.04下从零起步搭建配置github.io博客——Hexo","slug":"Ubuntu-Github-io-config-Hexo","date":"2017-11-09T16:00:00.000Z","updated":"2018-02-02T08:57:00.459Z","comments":true,"path":"2017/11/10/Ubuntu-Github-io-config-Hexo/","link":"","permalink":"https://lrscy.github.io/2017/11/10/Ubuntu-Github-io-config-Hexo/","excerpt":"","text":"前言本文利用Github io和Hexo搭建静态博客。主题更换等问题请到Hexo Theme里寻找并替换。 继上次用Jekyll搭建博客后，又忙了很多其他事情，接触到了Hexo。因此决定将博客从Jekyll换到Hexo。 本人是个前端小白，按照网上众多教程搭建时候依旧踩了很多坑，在此记录下来以便有相同问题的同学可以快速解决。 搭建Github io静态博客所需基础之基础的知识如下： Git Github Markdown Hexo 本文是在Ubuntu 17.04环境下配置的，如果使用其他操作系统请自行查找对应命令或者解决方案。 以下代码区域，带有$打头的表示需要在控制台（终端或称命令行）下面执行（不包括$符号）。如果出现权限不足提示请在命令最前面加上sudo再执行。 本文几乎所有命令都可以直接拷到控制台（终端或称命令行）内直接执行而不用理解其具体含义（除非特殊表明需要修改），但是强烈不建议这么做！！！ 我是基于Hexo模板搭建的博客，所以不会讲如何从零手敲出一个博客样式出来，但会比较详细的讲模板中哪里需要修改。 基础环境搭建Git/Github/SSH配置详见我的博客「Ubuntu16.04下Github配置」。 Node.js安装安装Hexo前需要安装Node.js，本人安装的是Node.js 8。 对于Ubuntu系列系统，执行以下两个命令：12$ curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -$ sudo apt-get install -y nodejs 如果系统中没有安装curl，执行下述命令安装：1$ sudo apt-get install curl 安装完成后需要检查下node和npm的版本：12$ node -v$ npm -v 分别显示出版本号就算安装完成了～本站搭建时node版本为v8.9.1，npm版本为5.5.1。 参考资料Node.js官网。 Hexo本地建站Hexo安装Hexo安装非常简单，上述环境搭建好后只需执行以下命令即可：1$ npm install -g hexo-cli 本站搭建时Hexo的版本是3.4.0。 Hexo本地建站首先通过终端进入希望建站的文件夹内（例如~/Hexo），执行以下命令：1$ hexo init 该命令要求建站文件夹是全空的文件夹。如果之前在该文件夹内建立了git等文件（夹），请先移出文件夹，建站完成后再移回来。 下述命令会在该文件夹下建立所有需要的文件。接下来安装依赖包：1$ npm install 至此，Hexo本地博客已经搭建完成。对，你没看错～ 然后执行以下命令来浏览本地站点12$ hexo generate$ hexo server hexo generate是用来编译生成站点，每次对站点内容编辑后都要进行该项操作。可以简化为hexo g。 hexo server是用来启动本地站点，执行后即可在浏览器中输入localhost:4000查看。可以简化为hexo s。 参考资料Hexo 官方文档 Github io部署博客_config.yml参数设置部署配置在_config.yml文件的末尾，默认样子如下：12345# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:type:repo: 修改后如下：123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:type: gitrepo: http://github.com/xxx/xxx.github.io.git(xxx是Github账户名称)branch: master 由于是部署到Github中，所以type是git。 repo是指Github对应仓库的SSH地址。点击该仓库页面右侧绿色download，里面的地址就是SSH地址。 branch是指上传到Github的哪个分支，如果没特殊需求选择master就可以。特殊需求请自行填写上传哪个branch。 插件安装为了部署到Github上，需要安装hexo-deployer-git插件，命令如下：1$ npm install hexo-deployer-git --save 最终部署最终部署需要输入以下两个命令：12$ hexo generate$ hexo deploy hexo generate同上。 hexo deploy将hexo部署到Github io上。可以简化为hexo d。 上传后需要等待几分钟，然后就可以在浏览器中输入xxx.github.io来欣赏了喵～ 参考资料Hexo 部署","categories":[{"name":"Config","slug":"Config","permalink":"https://lrscy.github.io/categories/Config/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://lrscy.github.io/tags/Hexo/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://lrscy.github.io/tags/Ubuntu/"},{"name":"Github.io","slug":"Github-io","permalink":"https://lrscy.github.io/tags/Github-io/"}]},{"title":"Ubuntu系统NVIDIA显卡驱动安装","slug":"Ubuntu-NVIDIA-Driver-Install","date":"2017-10-09T16:00:00.000Z","updated":"2018-02-02T08:58:27.624Z","comments":true,"path":"2017/10/10/Ubuntu-NVIDIA-Driver-Install/","link":"","permalink":"https://lrscy.github.io/2017/10/10/Ubuntu-NVIDIA-Driver-Install/","excerpt":"","text":"前言本文是在Ubuntu 17.04系统上安装NVIDIA驱动。 在Ubuntu 16.04 LTS上安装驱动时是从NVIDIA 官网上下载.run文件然后按照提示安装，但是在Ubuntu 17.04上并不成功。因此寻找到了一种更为简便的方法，记录在此。 如果要在本机安装NVIDIA Driver的话请先用手机等设备照下关键步骤然后再执行。 安装准备查找合适的驱动在NVIDIA 官网上寻找合适的驱动，并记住其版本号。例如，384.98的版本号是384。 关闭图形界面首先按住Ctrl+Alt+F1进入tty1模式，然后输入如下代码关闭图形界面（X Server）：1$ sudo stop lightdm lightdm指的是图形界面服务 卸载之前的NVIDIA显卡驱动如果之前有尝试过其他驱动，则需要将其卸载步骤如下：1$ sudo apt remove nvidia-* 如果采用的是.run文件安装的系统请采用如下命令卸载：1$ sudo ./NVIDIA-*.run --uninstall 这里NVIDIA-*.run是下载的.run文件全名。 安装NVIDIA显卡驱动因为无法通过.run方式安装驱动，因此采用从第三方源的方式安装驱动。 添加第三方源这次采用的是mamarley源，添加该源的命令如下：1$ sudo add-apt-repository ppa:mamarley/nvidia 然后进行更新源1$ sudo apt update 安装NVIDIA显卡驱动在添加好第三方源后采用apt方式安装，命令如下：1$ sudo apt install nvidia-384 本文安装的是384版本，请按照个人不同的需求输入合适的驱动版本号。 至此，驱动已经安装完成，但是请不要立即启动lightdm服务。请先输入以下命令重启系统：1$ reboot 检查安装结果在命令行输入如下结果：12$ nvidia-smi$ nvidia-settings 输入nvidia-smi命令后输出一个表格即为正常。输入nvidia-settings出现下图即为正常。 NVIDIA-X-Server-Settings 异常处理如果安装显卡后出现循环登录不进入桌面的情况请执行“安装准备”中的“关闭图形界面”和“卸载之前的NVIDIA显卡驱动”。 卸载驱动卸载驱动请按照“卸载之前NVIDIA驱动”所述内容进行卸载并重启。","categories":[{"name":"Config","slug":"Config","permalink":"https://lrscy.github.io/categories/Config/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://lrscy.github.io/tags/Ubuntu/"},{"name":"NVIDIA","slug":"NVIDIA","permalink":"https://lrscy.github.io/tags/NVIDIA/"}]},{"title":"Ubuntu 16.04下(多)SSH配置","slug":"Ubuntu-SSH-config","date":"2017-05-01T16:00:00.000Z","updated":"2018-02-02T08:59:02.124Z","comments":true,"path":"2017/05/02/Ubuntu-SSH-config/","link":"","permalink":"https://lrscy.github.io/2017/05/02/Ubuntu-SSH-config/","excerpt":"","text":"前沿本文记录了我配置同机多SSH时候的全过程。本文是在Ubuntu 16.04 LTS下配置的，如果使用其他操作系统请自行查找对应命令或解决方案。以下代码区域，带有$打头的表示需要在控制台（终端或称命令行）下面执行（不包括$符号） SSH安装Ubuntu 16.04 LTS自带openssh客户端，但是不带openssh服务器端。如果需要ssh localhost连接本地，那么需要安装openssh-server，命令如下：1$ sudo apt install openssh-server 如果你的机器上没有装客户端的话需要执行以下命令安装：1$ sudo apt install openssh-client 至此，基础环境已经安装完了。 单SSH配置此节操作只适用于只需要免密码登录一个远程服务器的同学，如果你需要同时SSH远程登录多个服务器，那么请直接跳至下一节。 对于单SSH配置，你只需要输入以下命令即可，此时为默认状态，你的个人信息不会被加入进去：1$ ssh-keygen -t rsa 如果你需要将个人信息（如邮箱）加入进去（比如远程访问Github时），那么请执行如下命令：1$ ssh-keygen -t rsa -C \"youraddress@youremail.com\" 这里有几点需要注意的： -C中的C是大写字母 youraddress@youremail.com是你Github的注册邮箱 对于上述两条命令，如果你远程登录时候需要设置密码，那么请在其提示时候输入密码。然后一路回车即可。 然后你会发现在你的家目录（~或者/home/username/）下多了一个叫做.ssh的文件夹，里面有两个文件id_rsa和id_rsa.pub。这两个就是SSH生成的文件，你需要将公钥传给远程服务器（Github相关问题详见Ubuntu16.04下Github配置博文），然后就可以免密码远程登录了。 多SSH配置建立不同的SSH配置文件首先你需要在家目录（~或者/home/username/）下建立一个.ssh文件夹，命令如下：1$ mkdir .ssh 然后进入该文件夹（建议进入）：1$ cd ~/.ssh 在该文件夹下，输入以下命令，后面我会介绍每个参数的作用：1$ ssh-keygen -t rsa -f ~/.ssh/id_rsa.blabla 如果你需要将个人信息（如邮箱）加入进去（比如远程访问Github时），那么请执行如下命令：1$ ssh-keygen -t rsa -f ~/.ssh/id_rsa.blabla -C \"youraddress@youremail.com\" 下面我们来分析下这两个命令。 -t rsa是指定你的加密算法。 -f是指定你的文件存储位置，我建议存在~/.ssh文件夹中。文件明明我建议按照我的格式写，blabla是该SSH配置文件的用途，比如.github, .localhost之类的。 -C注意这里C是大写字母。这里填写你的邮箱地址（顺便提一句配置Github时一定要填写你的注册邮箱，详见Ubuntu16.04下Github配置）。 建立索引因为你有多对SSH配置文件（.blabla和.blabla.pub是一对私钥和公钥），所以在远程登陆时，系统需要知道你需要将哪份私钥和远程的公钥进行匹配。所以你需要一个索引文件config。输入如下命令建立该文件：1$ touch config 文件格式如下：1234Host name HostName hostname User username IdentityFile filepath 一个config文件中可以有多个上述结构，每个结构之间建议用一个空行隔开。下面解析下这个结构。 Host就是个名字，每个结构之间不得重复 HostName是远程主机的域名，比如github.com, localhost之类或者是一个固定的IP地址。 User就是你登录该远程主机的用户名。 IdentityFile就是对应该主机的私钥的文件路径。依上述教程，应为~/.ssh/id_rsa.blabla。 登录localhost在配置软件环境时，有软件需要免密码登录localhost，也就是免密码登录本机。此时，你需要在.ssh目录下建立authorized_keys文件，命令如下：1$ touch authorized_keys 建立此文件的目的是存储已知的SSH公钥信息。此时你需要将localhost的公钥复制进来。如果你是单SSH配置，则需要把id_rsa.pub文件复制进来。命令如下：1$ cat id_rsa.pub &gt;&gt; authorized_keys 如果你是多SSH配置，依上述教程，你需要把id_rsa.localhost.pub复制进来，命令如下：1$ cat id_rsa.localhost.pub &gt;&gt; authorized_keys 然后你就可以免密码登录localhost了。另外，如果需要添加其他已知SSH公钥的话，直接往authorized_keys中添加即可。 常见提示及应对方法第一次登录第一次远程登录一个新的主机时一般会出现如下提示：123The authenticity of host 'xxx.com (xx.xx.xx.xx)' can't be established.RSA key fingerprint is xx:xx...xx:xx.Are you sure you want to continue connecting (yes/no)? 输入yes即可。然后可能会出现如下警告，意味着要永久存储该机器的特征信息，不用理睬即可：1Warning: Permanently added ‘xxx.com,xx.xx.xx.xx’ (RSA) to the list of known hosts. known_hosts文件当你访问远程主机时，系统会记录远程主机的特征信息，这些信息都存储在known_hosts里面。如果你不小心删掉了的话，也没什么事请，就是下一次进行SSH链接时还会出现第一次登录的提示，按照提示输入yes即可。","categories":[{"name":"Config","slug":"Config","permalink":"https://lrscy.github.io/categories/Config/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://lrscy.github.io/tags/Ubuntu/"},{"name":"SSH","slug":"SSH","permalink":"https://lrscy.github.io/tags/SSH/"}]},{"title":"Ubuntu 16.04下Ruby基础配置","slug":"Ubuntu-Ruby-base-config","date":"2017-04-30T16:00:00.000Z","updated":"2018-02-02T08:58:40.756Z","comments":true,"path":"2017/05/01/Ubuntu-Ruby-base-config/","link":"","permalink":"https://lrscy.github.io/2017/05/01/Ubuntu-Ruby-base-config/","excerpt":"","text":"Note: 本文内容节选复述了Ruby-China中的教程中的内容，其中有一两步和原版有出入（我踩到的坑）。如果需要看原版内容请点击上述链接。 本文是在Ubuntu 16.04 LTS环境下配置的，如果使用其他操作系统请自行查找对应命令或解决方案。 以下代码区域，带有$打头的表示需要在控制台（终端或称命令行）下面执行（不包括$符号） 由于ubuntu自带的ruby版本太老，所以需要从下列途径更新。 安装系统需要的包12$ sudo apt-get install curl$ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 其中curl是一种下载工具，在后续操作中需要用到。 安装RVMRVM安装只需输入以下命令：1234$ gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3$ curl -sSL https://get.rvm.io | bash -s stable# 如果上面的连接失败，可以尝试: $ curl -L https://raw.githubusercontent.com/wayneeseguin/rvm/master/binscripts/rvm-installer | bash -s stable 如果其中某些命令出现权限不足提醒，则在前面添加sudo再执行即可。 接下来载入RVM环境1$ source ~/.rvm/scripts/rvm 接下来有一点和教程中不太一样（我踩到的坑）。打开~/.bash_profile文件你可能发现如下一行：1[[ -s \"$HOME/.rvm/scripts/rvm\" ]] &amp;&amp; source \"$HOME/.rvm/scripts/rvm\" # Load RVM into a shell session *as a function* 原文中说“新开的终端就不想要这么做了，会自动重新载入的”正因为RVM安装程序在.bash_profile中添加了这么一行。然而你可能发现现实很残酷，新开的终端并没有载入rvm环境。此时你需要在家目录（～）下的.bashrc文件中的末尾添加如下几行：12# Add RVM to PATH for scripting. Make sure this is the last PATH variable change.[[ -s \"$HOME/.rvm/scripts/rvm\" ]] &amp;&amp; source \"$HOME/.rvm/scripts/rvm\" 其实也就是复制到.bashrc中而已。然后重启终端即可，如果还不行那么注销重新登录即可，如果还不行请重启机器。 然后修改RVM下的Ruby源，到Ruby China的镜像：1$ echo \"ruby_url=https://cache.ruby-china.org/pub/ruby\" &gt; ~/.rvm/user/db 检查下是否安装正确1$ rvm -v 用RVM按转Ruby环境12$ rvm requirements$ rvm instll 2.4.0 这里的版本号（2.4.0）可以通过下属命令查看并可修改：1$ rvm list 设置Ruby版本RVM 安装好后，需要执行下述命令将指定版本设为系统默认版本1$ rvm use 2.4.0 --default 这个时候你可以测试是否正确12$ ruby -v$ gem -v 这里你可以替换原有的gem源到Ruby China的源或者淘宝源，分别是：12$ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/$ gem sources --add https://ruby.taobao.org/ --remove https://rubygems.org/ 可以通过下属命令查看gem源：1$ gem sources -l 接下来安装Bundler1$ gem install bundler 设置Rails环境输入以下命令就可以轻松安装上Rails了：1$ gem install rails 测试是否安装正确1$ rails -v 至此，Ruby基础安装教程到此结束喵～","categories":[{"name":"Config","slug":"Config","permalink":"https://lrscy.github.io/categories/Config/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://lrscy.github.io/tags/Ubuntu/"},{"name":"Ruby","slug":"Ruby","permalink":"https://lrscy.github.io/tags/Ruby/"}]},{"title":"Ubuntu 16.04下Github配置","slug":"Ubuntu-Github-config","date":"2017-04-30T16:00:00.000Z","updated":"2018-02-02T08:56:46.455Z","comments":true,"path":"2017/05/01/Ubuntu-Github-config/","link":"","permalink":"https://lrscy.github.io/2017/05/01/Ubuntu-Github-config/","excerpt":"","text":"前言本文记录了我配置Github时候的全过程。 本文是在Ubuntu 16.04LTS下配置的，如果使用其他操作系统请自行查找对应命令或解决方案。 以下代码区域，带有$打头的表示需要在控制台（终端或称命令行）下面执行（不包括$符号） Git安装Ubuntu下需要安装git，输入命令如下：1$ sudo apt-get install git Github账户注册你需要一个Github的账户才能使用github.io服务。所以去github.com点击右上角的Sign Up注册即可。 SSH配置我们需要使用ssh来和github上的远程仓库进行通信，所以需要检查和配置ssh。 首先需要检查电脑上现有的ssh key:1$ cd ~/.ssh 如果提示：No such file or dictionary 则说明你是第一次使用git。 如果你是第一次使用git，那么你需要做如下工作。否则可以跳过此节。 生成新的SSH KEY:1$ ssh-keygen -t rsa -C \"youraddress@youremail.com\" 这里有几点需要注意的： -C中的C是大写字母 youraddress@youremail.com是你Github的注册邮箱其余的一路回车就能完成了。其中.pub是公钥，需要给到远程主机上，这点我们下一节再讲。 如果你需要连接多ssh终端，详见「Ubuntu16.04下(多)SSH配置」。 Github配置仅仅本地配置好了是不够的，你需要让你的github账户认识你。所以你需要按照以下步骤操作： 去登录github账户，在右上角点击头像找到Settings 点进去后点击左侧栏中的SSH and GPG keys 点击右侧New SSH key 随意输入个能带便当前机器的名字，并把本地.ssh目录下生成的关于github的.pub文件拷贝进来 保存即可 Github连接检查当一切配置妥当后，在终端中输入1$ ssh -T git@github.com 如果你是第一次输入此命令，可能遇到如下提示：123The authenticity of host 'github.com (207.97.227.239)' can't be established.RSA key fingerprint is xx:xx...xx:xx.Are you sure you want to continue connecting (yes/no)? 此时输入yes即可，然后会出现：1Hi xxx! You've successfully authenticated, but GitHub does not provide shell access. 此时表明你的github配置完成了 本地个人信息配置此时你已经可以通过SSH连接到Github了，但是还有一些个人信息需要完善才能够和Github愉快的通信。 Git会依据本地设定的用户名和邮箱向远程主机提交更改，Github也是依据这些信息进行权限管理的。如果你当前只使用一个Github帐号，那么你需要以下两个命令来完善本地个人信息设定：12$ git config --global user.name \"your github name\"$ git config --global user.email \"youraddress@youremail.com\" 上述命令中your github name是你的github用户名，youraddress@youremail.com是你github的注册邮箱。 如果你需要配置多Github账户，则需要用如下命令将–global所设置的参数撤销掉：12$ git config --global unset user.name$ git config --global unset user.email 在每个git根目录下自行建立个人信息，命令如下：12$ git config user.name \"your github name\"$ git config user.email \"youraddress@youremail.com\" 上述命令中your github name是你的github用户名，youraddress@youremail.com是你github的注册邮箱。 至此，Github配置已全部完成。","categories":[{"name":"Config","slug":"Config","permalink":"https://lrscy.github.io/categories/Config/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://lrscy.github.io/tags/Ubuntu/"},{"name":"SSH","slug":"SSH","permalink":"https://lrscy.github.io/tags/SSH/"},{"name":"Github","slug":"Github","permalink":"https://lrscy.github.io/tags/Github/"}]},{"title":"Ubuntu 16.04下从零起步搭建配置github.io博客——Jekyll","slug":"Ubuntu-Github-io-config-Jekyll","date":"2017-04-29T16:00:00.000Z","updated":"2018-02-02T08:57:53.275Z","comments":true,"path":"2017/04/30/Ubuntu-Github-io-config-Jekyll/","link":"","permalink":"https://lrscy.github.io/2017/04/30/Ubuntu-Github-io-config-Jekyll/","excerpt":"","text":"前言本文旨在将我配置github.io博客全过程展现出来，帮助从零起步的小白们一步一步的配置属于自己的github.io博客。如果过程正哪一步骤错了，请各位大佬指出，谢谢～ 小白的入门门槛： 需要耐心，耐心，耐心碰到问题自主去学习和在网上寻找答案 本文是在Ubuntu 16.04 LTS环境下配置的，如果使用其他操作系统请自行查找对应命令或解决方案。 以下代码区域，带有$打头的表示需要在控制台（终端或称命令行）下面执行（不包括$符号） 本文几乎所有命令都可以直接拷到控制台（终端或称命令行）内直接执行而不用理解其具体含义（除非特殊表明需要修改），但是强烈不建议这么做！！！ 我是基于Jekyll模板搭建的博客，所以不会讲如何从零手敲出一个博客样式出来，但会比较详细的讲模板中哪里需要修改。 基础环境搭建Git/Github/SSH配置详见我的博客「Ubuntu16.04下Gtihub配置」。 本地Jekyll环境配置因为github.io博客是基于Jekyll模板生成的，所以需要了解下Jekyll模板。其实本地不配置Jekyll也是可以的，不过后果就是无法进行本地预览。提交到Github上平均需要10分钟才能看到更改结果，所以我是建议本地配置下Jekyll的。 Ruby安装配置Jekyll是基于ruby的，所以要安装Jekyll还需要安装ruby, gem等。不过不要担心，我已经把雷都踩过了，你只需要跟着我一步步走就好。不过，我们不需要把Rails环境配上，因为我们暂时用不到。 详见我的博客「Ubuntu16.04下Ruby基础配置」。 Jekyll安装配置由于上一步已经安装好了Ruby和gem了，所以只需要下面一条命令就可以安上Jekyll：1$ gem install jekyll 没了，嗯～ 真的没骗你～喵～ 至此基础环境搭建也就完成了。 Jekyll目录介绍我会对Jekyll目录进行一个简单粗略的介绍，让你知道每个目录大概都是做什么的，便于你以后查找需要修改的文件的位置。 Note: 我的博客是基于其他作者些的Jekyll主题改的，所以以下部分所述“不需要修改”皆出于此出发点。对于有前端基础的同学请自行忽略。 下面是目录树：123456789101112131415161718192021blog _includes footer.html head.html header.html _layouts default.html page.html post.html _posts 2017-04-30-Hello.md _sass _site css main.scss .gitignore .sass-cache _config.yml about.md feed.xml index.html _include这里都是网页模块文件，用来加载到你的布局或文章中。以后可能需要修改部分内容。可以在其他文件中采用如下方法调用该文件夹内文件：1&#123; % include file %&#125; Note: 调用时候把{和%之间的空格去掉 _layouts存放网页模板。每个网页只需要关注自己的内容。也基本上不用修改。 _posts这里就是存放我们博文的地方了。文件名称非常非常关键，必须使用统一的格式：YEAR-MONTH-DAY-TITLE.md且中间不能有空格。例如：2017-04-30-Hello.md。不是此格式的博文不会被解析也不会在网站中显示。 _sass存放网站用到的sass文件。基本上你不用管这里面做了些什么。 _site在Jekyll解析完成这些文件后，会将最终的静态网站源代码默认的放在这个文件夹下来保存。这个文件夹最好添加进.gitignore文件中（这个问题我们后面再说）。 css存放网页样式文件。基本上也不用管。 .sass-cachesass的编译缓存文件。基本上你不用管这里面都是什么。 _config.yml最重要的配置文件，这里面决定了Jekyll如何解析网站源代码。官方有给出配置文件详细信息，详情请见这里。 _plugins你可能需要这个文件夹也可能不需要，按需建立此文件夹。这里用来存放Jekyll插件。 正式开始搭建博客终于开始搭博客了喵～ Github仓库建立本节是在复述官方教程中的内容。 建立一个仓库你需要在你的Github中建立一个新的仓库，名字必须是{your github username}.github.io，否则Github不会将其认为是Github博客。 克隆到本地采用下述命令进行复制1$ git clone https://github.com/username/username.github.io 这里的username是你的github用户名 至此，Github部分完结 Jekyll模板我的博客是基于Pithy主题建立的。Jekyll模板可以从Jekyll Theme上或大佬们的Github上下载。下载解压后直接将所有文件都拷贝到自己刚克隆下来的文件夹下即可。 _config.yml解压后唯一需要修改的部分，修改其中所有你认识的英文，如果没有可以填的空着就好。 接下来你需要做的就是将其push到远程仓库里。如果你不熟悉Git操作命令，我强烈建议你去看下廖雪峰的Git教程。 添加.gitignore文件上文介绍jekyll结构的时候说了句_site要加入.gitignore文件中。.gitignore文件是git上传时要过滤掉的文件。依据自己需求改下就可以了。我目前的.gitignore文件如下：1234_site/*.sass-cache.jekyll-metadata.swp 搭完了，嗯，你没看错，搭完了喵～ 添加Mathjax支持作为一个技术小白，就算再小白也有需要用到数学公式的时候。这时mathjax能满足你的大部分需求。Mathjax配置很简单，过程如下： 在_include/head.html中添加以下代码：1234567891011&lt;script type=\"text/x-mathjax-config\"&gt; MathJax.Hub.Config(&#123; TeX: &#123; equationNumbers: &#123; autoNumber: \"AMS\" &#125; &#125;, tex2jax: &#123; inlineMath: [ ['$','$'], ['\\\\(', '\\\\)'] ], displayMath: [ ['$$','$$'] ], processEscapes: true, &#125; &#125;);&lt;/script&gt;&lt;script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\"&gt;&lt;/script&gt; 最后一行那里的src，有些博客包括官方教程些的都是http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML，然而在https下此网址被认为是不安全的而一些浏览器被屏蔽了（比如Chrome），所以需要换成这个网址。 然后你需要检查下_config.yml中是否有如下一行：1markdown: kramdown 如果没有添加上即可。这是在指定markdown的解释器，如果你想换成其他的也可以。 至此，Mathjax配置完成了。用在行内用$来包裹latex公式，行间公式需要用$$包裹住。例子如下：123456# 第一种blabla$x$blabla# 第二种$$P(y|x)$$ 添加代码高亮我选择的是Jekyll原生支持的rouge进行代码高亮。只需要在_config.yml中添加一行：1highlighter: rouge 即可高亮代码。 最后的检测现在你已经配好了所有功能，在git仓库的根目录下运行jekyll serve即可以迅速在本地生成博客。通过浏览器访问localhost:4000即可看到成果啦喵～ 最后的最后记得push到你Github的远程仓库中，然后就可以在网页上看到你自己的博客了。","categories":[{"name":"Config","slug":"Config","permalink":"https://lrscy.github.io/categories/Config/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://lrscy.github.io/tags/Ubuntu/"},{"name":"Github.io","slug":"Github-io","permalink":"https://lrscy.github.io/tags/Github-io/"},{"name":"Jekyll","slug":"Jekyll","permalink":"https://lrscy.github.io/tags/Jekyll/"}]},{"title":"「译」GPU神经网络机器翻译导论（第一部分）","slug":"Trans-Intro-to-NMT-with-GPUs-part1","date":"2017-04-28T16:00:00.000Z","updated":"2018-02-03T04:25:59.919Z","comments":true,"path":"2017/04/29/Trans-Intro-to-NMT-with-GPUs-part1/","link":"","permalink":"https://lrscy.github.io/2017/04/29/Trans-Intro-to-NMT-with-GPUs-part1/","excerpt":"","text":"原文名：Introduction to Neural Machine Translation with GPUs (part 1) 翻译自NVIDIA 深度学习系列 「译者注：博文中有些链接指向Google Drive，需要各位同学科学上网查阅资料。」 注意：这篇是Kyunghyun Cho写的神经网络机器翻译系列中的第一篇。其余的请见第二部分和第三部分。 神经网络机器翻译是近期被提出的的一个框架，其只基于神经网络。此篇文章是该系列的第一篇文章，我将阐述一个简单的编码-解码模型来构建一个神经网络机器翻译系统「Cho et al., 2014; Sutskever et al., 2014; Kalchbrenner and Blunsom, 2013」。后面的文章我将阐述如何将注意力机制融入简单的编码-解码模型中「Bahdanau et al., 2015」，并且形成好的英法、英德、英土和英中翻译模型「Gulcehre et al., 2015; Jean et al., 2015」。此外，我将介绍一些近期最新的进展——将此神经网络机器翻译框架应用于描述图像和视频的。 统计机器翻译首先，我们简单的阐述下机器翻译。事实上，机器翻译是个统称。我们希望机器将一种语言（我们称之为源语言）翻译成另一种语言（我们称之为目标语言）。（尽管理想情况下，机器应该能够将一整篇文档从一种语言翻译到另一种语言，但是我们在此篇博客中专注于句子级别的机器翻译。） 我们有许多方式去构建一台能够翻译语言的机器。例如，我们可以请教一个同时会两门语言的的人为我们构建一套翻译规则来将源语言正确的翻译成目标语言。但是这不是一个好的解决方案，联想下我们自己，我们可能都无法完整的构建出我们母语的语法规则，更别提构建两个语言规则之间的对应了。写一套详尽的翻译规则将源语言翻译成目标语言更是痴心妄想。因此，在此篇博文中，我们将专注于利用统计的方法，通过大量的文本语料库来提取这些隐式和显式的规则。 这种通过统计方法进行机器翻译的方法被成为统计机器翻译。虽然最终目标是相同的（建立一个能将一个句子从一种语言翻译到另一种语言的机器），但是我们让机器从数据中学习如何翻译而非学习如何构建规则（如图1的图解）。此学习是基于统计的方法，每个学习过机器学习的人都应该很熟悉此方法。事实上，统计机器翻译只是机器学习的一种特定的应用——寻找一种从源语言到相关目标语言的对应关系。 图1. 统计机器翻译 机器翻译的一个重要的特征是翻译函数并非像其他机器学习应用一样是一对一的或多对一的（例如分类应用的函数就是多对一的），而是一对多的，也就是说一个源句子可能有多个可能的翻译结果。正因如此，模型的方法不是个确定性函数而是一个目标句子$y$对$x$的条件概率$p(y|x)$。条件概率能够对于多个分离度良好的结构或句子分配同等的高概率，这就使得源语言和目标语言的一对多关系得以成立。 现在，我们假设你将建立一个统计机器翻译系统并且要将英语翻译成法语。第一步且可能是最重要的一步是收集平行语料。我们用$x^n$和$y^n$来分别表示源语句和对应的翻译语句。上标$n$代表这是第$n$对语句（通常我们需要成千上万对语句才能训练出一个好的翻译模型）。我将用$D=(x^1,y^1),…,(x^N,y^N)$来表示数据中有$N$对语句对。 我们从哪里能得到这些训练语句对呢？对于机器翻译中广泛使用的语言，你可能想要查看统计机器翻译研讨会 (EMNLP)或者国际语言翻译研讨会 (IWSLT)。 在有了训练集$D=(x^1,y^1),…,(x^N,y^N)$后，我们能够通过观察这个模型在训练集$D$上的表现给这个模型打分。这分数（我将称之为模型的对数似然）是该模型对每一对$(x^n,y^n)$的对数似然的平均值。利用机器翻译模型的概率解释，模型在每一对上的对数似然只是模型给这一对语料$log⁡(y^n|x^n,θ)$评估的对数概率有多高。然后，整个模型的在训练集上的打分如下： $$ \\mathcal{L}(\\theta, D) = \\sum_{(x^n, y^n) \\in D} \\log p(y^n|x^n, \\theta) $$ 如果对数似然值$\\mathcal{L}$很低，说明该模型没有分配给正确翻译句对足够的概率，也意味着该模型将部分概率分配给了错误的翻译。所以，我们希望找到一种模型的结构或者参数$θ$来最大化对数似然或得分。 在机器学习中，这被称为最大似然估计。除此之外我们还有一个更重要的问题：我们如何建立模型$p(y|x,θ)$？ 统计机器翻译简述IBM T.J. 沃森研究中心「Brown et al., 1993等其他参考文献」在20多年前就已经提出并回答了如何建立条件分布模型。从那时起，统计机器翻译(SMT)的核心就是一个线性对数模型，我们用有许多特征的线性组合近似了$p(y|x)$的对数： $$ \\log p(y|x) \\approx \\log p(y|x, \\theta) = \\sum_i \\theta_i f_i(x, y) + C(\\theta), $$ 其中$C$是归一化常数。在这种情况下，很大一部分研究工作是要找到一组很好的特征函数f_i，并且有一本书已经详尽描述了关于其的所有细节「Koehn」。 在这种统计机器翻译方法中，通常来说机器学习需要做的只是寻找到一组能够平衡不同特征的系数θ_i，或者从对数线性模型「Schwenk, 2007」中筛选或重新排序一组可能的翻译。更具体来所，神经网络已经被用作组成特征函数功能的一部分，也可以用来重新排序所谓的最佳可能翻译的列表，就像图2中中间和右边部分。 图2. 图解NMT，SMT+神经网络重新排序和SMT-NN。从「Bahadanau et al., 2015」在ICLR2015中的幻灯片中截取 另一方面，在此篇博客中，我将专注于最近提出一种称为神经网络机器翻译的方法。其中机器学习，特别是神经网络，拥有更多甚至全部的控制权。正如图2中左边部分所展示的。 神经网络机器翻译就像普通的深度学习一样，神经网络机器翻译(NMT)不依赖于已经提前设计好的方法。（通过提前设计好的方法，也就是说那些没有学习的功能。）相比而言，NMT设计的目标是设计一个完全可训练的模型，其每一部分都是基于语料库进行调整，以最优化其翻译表现。 一个完全可训练的NMT模型$\\mathcal{M}$从尽可能的地道的表述源语言语句开始训练，到生成尽可能地道的目标语言语句停止。目前，我们来考虑一个词序列视作作一个句子的最原始的表示。（虽然对于大多数语言来说这并不合理，但是在尽可能的保证一般性的前提下，我会将词作为一个语言的最小的单位。）每一个序列中的词都被它在字典中的索引数字代替。例如，在基于词频率的英语词典中，第一个出现的词会被表示为整数1。我将用$X=(x_1,x_2, \\cdots, x_T)$来表示源句子，用$Y=(y_1, y_2, \\cdots, y_{T’})$来表示目标句子。 给出源句子$X=(x_1,x_2, \\cdots, x_T)$的词索引，NMT模型$\\mathcal{M}$会计算$Y=(y_1, y_2, \\cdots, y_{T’})$的条件概率。接下来，我将阐述我们如何来建立一个神经网络来近似条件概率的条件概率。接下来，我将阐述我们如何来建立一个神经网络来近似条件概率$p(Y|X)$。 循环神经网络机器翻译的一个重要的特征，或是说基于自然语言的任何任务，是处理可变长度输入$X=(x_1,x_2, \\cdots, x_T)$和可变长度输出$Y=(y_1, y_2, \\cdots, y_{T’})$。换句话说，$T$和$T’$不固定。 为了处理这些可变长度的输入和输出，我们需要用到循环神经网络（RNN）。目前广泛应用的前馈神经网络（比如卷积神经网络）除了网络自身的参数外不保留中间状态。无论何时，一个样例进入前馈神经网络，无论网络内部参数还是隐藏层的激活都是重新计算的而不受前一个样本的状态结果的影响。然而RNN在读入一个序列时保存了其内部状态（在当前情况下是词序列），因此能够处理任何长度的输入。 我接下来将更详细的解释一下RNN。RNN的主要的思想是通过使用递归将输入的序列压缩成一个固定维度的向量。假设在第$t$步我们有一个向量$h_{t-1}$保存了之前所有的符号的状态。RNN将计算出一个新的向量（或称为内部状态），$h_t$通过下式压缩了之前所有符号$\\left(x_1, x_2, \\dots, x_{t-1} \\right)$包括新的符号$x_t$： $$ h_t = \\phi_{\\theta}(x_t, h_{t-1}) $$ 其中$\\phi_{\\theta}$是由$\\theta$参数化的一个函数，以新符号$x_t$和保存了前$(t−1)$个符号的历史状态$h_{t-1}$作为输入。最开始，我们可以放心的假设$h_0$是一个全零向量。 图3. 图解不同类型的循环神经网络。摘自「Pascanu et al., 2014」 递归激活函数$\\phi$通常被实现为一个非线性函数套着一个放射变换： $$ h_t=\\tanh(Wx_t + Uh_{t-1} + b) $$ 在这个等式中，参数包括输入权重矩阵$W$，循环权重矩阵$U$和一个偏差向量$b$。我必须强调这不是唯一的实现方案，现在依旧有很多的机会来设计新的循环激活函数。见图三的一些例子「Pascanu et al., 2014」。 这种简单的RNN可以轻易的由Theano来实现，且Theano可以让你的RNN程序在CPU和GPU下透明的运行。详见循环神经网络实现词向量；注意，整个RNN代码总共不超过10行！ 最近，研究发现用更复杂的激活函数来训练循环神经网络有更好的效果且更加容易，比如LSTM「Hochreiter and Schmidhuber, 1997」和GRU「Cho et al., 2014」。 $$\\begin{align}r_t &amp;= \\sigma(W_rx_t + Urh_{t-1} + b_r) \\\\u_t &amp;= \\sigma(W_ux_t + r_t \\odot (U_uh_{t-1}) + b_u) \\\\h_t &amp;= u_t \\odot h_{t-1} + (1-u_t) \\odot \\tanh(Wx_t + r_t \\odot (U_uh_{t-1}) + b)\\end{align}$$ 正如上述情况下的简单循环激活函数，参数包括了输入矩阵$W$($W_r$和$W_u$)，循环神经矩阵$U$($U_r$和$U_u$)和偏差向量$b$($b_r$和$b_u$)。 虽然这些单元看起来比简单RNN复杂些，但是由Theano或者其他深度学习框架（比如Torch）实现起来会很简单。例如LSTM网络进行情感分析(样例代码)。 我已经将RNN表述为了一个历史压缩器，但是它也可以用来为一个序列进行概率建模。给一个序列进行概率建模的意思是让机器学习一个模型来计算任意给定序列$X=(x_1, x_2, \\cdots, x_T)$的概率$p(X)$。我们如何设计$p(X)$才能让其满足递归的形式呢？ 我们从重新将$p(X)=p(x_1, x_2, \\cdots, x_{T})$描述为下式开始： $$ p(x_1, x_2, \\cdots, x{T})=p(x_1)p(x_2|x_1)p(x_3|x_1, x_2) \\cdots p(x_T|x1, \\cdots, x_{T-1}) $$ 上述改变基于条件概率公式，$p(X|Y)=\\frac{P(X,Y)}{P(Y)}$。从上述改变我们可以看出，我们可以设计出一个递归表达式，例如： $$ p(x_1)p(x_2|x_1)p(x_3|x_1, x_2) \\cdots p(x_T|x_1, \\cdots, x_{T-1}) = \\prod_{t=1}^{T}p(x_t|x_{&lt;t}) $$ 现在我们使一个RNN模型$p(x_t|x_{&lt;t})$在每一步t$时进行如下操作： $$p(x_t|x_{&lt;t}) = g_{\\theta}(h_{t-1}) \\\\h_{t-1} = \\phi_{\\theta}(x_{t-1}, h_{t-2})$$ $g_{\\theta}$通过$h_{t-1}$输出基于前$(t-1)$个符号全部历史状态的条件分布概率。换句话说，在每个时刻，RNN试图通过学习输入符号的历史数据预测下一个字符应该是什么。 RNN有许多有趣的属性和特点值得我用上好几个小时来讲述，但是由于这是个博客，我不得就此停止。自此以后，我将讲述你们开始建立神经网络系统前的所有必备的知识。如果你想对RNN有更多的了解的话，我建议你去阅读下述论文。但是很明显，这些论文也并不能穷尽所有RNN有关的知识。你也可以去看我的关于如何将RNN应用于语言模型的幻灯片。 Graves, Alex. “Generating sequences with recurrent neural networks.” arXiv preprint arXiv:1308.0850 (2013). Pascanu, Razvan et al. “How to construct deep recurrent neural networks.” arXiv preprint arXiv:1312.6026 (2013). Boulanger-Lewandowski, Nicolas, Yoshua Bengio, and Pascal Vincent. “Modeling temporal dependencies in high-dimensional sequences: Application to polyphonic music generation and transcription.” arXiv preprint arXiv:1206.6392 (2012). Mikolov, Tomas et al. “Recurrent neural network based language model.” INTERSPEECH 2010, 11th Annual Conference of the International Speech Communication Association, Makuhari, Chiba, Japan, September 26-30, 2010 1 Jan. 2010: 1045-1048. Hochreiter, Sepp, and Jürgen Schmidhuber. “Long short-term memory.” Neural computation 9.8 (1997): 1735-1780. Cho, Kyunghyun et al. “Learning phrase representations using rnn encoder-decoder for statistical machine translation.” arXiv preprint arXiv:1406.1078 (2014). Bengio, Yoshua, Patrice Simard, and Paolo Frasconi. “Learning long-term dependencies with gradient descent is difficult.” Neural Networks, IEEE Transactions on 5.2 (1994): 157-166. 接下来的要讲述的事情在这篇博文中，我介绍了机器翻译，描述了统计机器翻译如何解决机器翻译的问题。在讲述统计机器翻译框架时，我讨论了神经网络如何用来提高翻译的整体表现。 这系列博客的目标是介绍一个新的神经网络机器翻译模型；这篇博文奠定了基础，重点介绍了循环神经网络的两个核心能力：序列总结能力和序列概率建模能力。 基于这两个特性，在下一篇博客中，我将讲述一个完整的基于循环神经网络的神经网络机器翻译系统。我也会想你展示为什么GPU对于神经网络机器翻译这么重要！","categories":[{"name":"NLP","slug":"NLP","permalink":"https://lrscy.github.io/categories/NLP/"}],"tags":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"https://lrscy.github.io/tags/Deep-Learning/"},{"name":"GPU","slug":"GPU","permalink":"https://lrscy.github.io/tags/GPU/"},{"name":"NLP","slug":"NLP","permalink":"https://lrscy.github.io/tags/NLP/"},{"name":"NMT","slug":"NMT","permalink":"https://lrscy.github.io/tags/NMT/"},{"name":"Theano","slug":"Theano","permalink":"https://lrscy.github.io/tags/Theano/"}]}]}