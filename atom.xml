<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Meow</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lrscy.github.io/"/>
  <updated>2018-02-11T14:17:51.903Z</updated>
  <id>https://lrscy.github.io/</id>
  
  <author>
    <name>Meow</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Cocos2d-x v3.16 Y轴翻转</title>
    <link href="https://lrscy.github.io/2018/02/11/Cocos2dx-3-16-Y-axis-Flip/"/>
    <id>https://lrscy.github.io/2018/02/11/Cocos2dx-3-16-Y-axis-Flip/</id>
    <published>2018-02-11T12:42:15.000Z</published>
    <updated>2018-02-11T14:17:51.903Z</updated>
    
    <content type="html"><![CDATA[<p>Cocos2d-x的设计中，setPosition等的原点是在屏幕左下角。例如：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="Normal.png" alt="正常坐标系" title="">                </div>                <div class="image-caption">正常坐标系</div>            </figure><p>但是当把触摸点坐标转换到屏幕坐标点时发现其原点在左上角。例如：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="Touch.png" alt="触摸坐标系" title="">                </div>                <div class="image-caption">触摸坐标系</div>            </figure><p>这样设计的好处是自然的支持纵向的“自然滚动”（即向下划的时候上面的内容自然出现，反之亦然）。然而当不需要这个功能的时候，会在坐标变换上小折腾下。</p><p>由于在处理多点触碰和缩放时候这个坐标转换耗费了不少的时间，为了以后懒得在这个上面再费时间和脑力（就是懒emmmm），归纳一点：“<code>旧纵坐标减新纵坐标</code>”。今后再有类似问题就来看着这条改下就好了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Cocos2d-x的设计中，setPosition等的原点是在屏幕左下角。例如：&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                   
      
    
    </summary>
    
      <category term="Cocos2d-x" scheme="https://lrscy.github.io/categories/Cocos2d-x/"/>
    
    
      <category term="Cocos2d-x" scheme="https://lrscy.github.io/tags/Cocos2d-x/"/>
    
      <category term="Axis" scheme="https://lrscy.github.io/tags/Axis/"/>
    
  </entry>
  
  <entry>
    <title>Cocos2dx-3.16-Android-Multi-Touch</title>
    <link href="https://lrscy.github.io/2018/02/11/Cocos2dx-3-16-Android-Multi-Touch/"/>
    <id>https://lrscy.github.io/2018/02/11/Cocos2dx-3-16-Android-Multi-Touch/</id>
    <published>2018-02-11T12:40:58.000Z</published>
    <updated>2018-02-11T14:06:12.635Z</updated>
    
    <content type="html"><![CDATA[<p>网上有关Cocos2d-x v3.x版本的多点触控的资料并不多，在尝试时发现了如下几个坑。跳出坑最好的办法就是去读官方给出的Testapp的源码，这样能看快的了解到官方时如何使用各种功能的，模仿和学起来都很快且很到位。如果更有能力的去多看看API和源码也是很好的学习途径。</p><h1 id="onTouchesBegan-Moved-Ended-Cancelled函数的参数"><a href="#onTouchesBegan-Moved-Ended-Cancelled函数的参数" class="headerlink" title="onTouchesBegan/Moved/Ended/Cancelled函数的参数"></a>onTouchesBegan/Moved/Ended/Cancelled函数的参数</h1><p>网上众多教程基本都是基于2.x版本，所用函数名及参数有许多为<code>cc</code>开头，且触摸回调函数的参数基本为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MoreTouches::ccTouchesMoved( cocos2d::CCSet *pTouches,</span><br><span class="line">                                  cocos2d::CCEvent *pEvent );</span><br></pre></td></tr></table></figure></p><p>在当前3.16版本中，其改为了<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onTouchesBegan</span><span class="params">( <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cocos2d::Touch *&gt; &amp;touches,</span></span></span><br><span class="line"><span class="function"><span class="params">                     cocos2d::Event *event )</span></span>;</span><br></pre></td></tr></table></figure></p><p>不再使用<code>set</code>作为触摸点的存储结构，而是采用<code>vector</code>。</p><h1 id="onTouchesBegan传入参数touches的问题"><a href="#onTouchesBegan传入参数touches的问题" class="headerlink" title="onTouchesBegan传入参数touches的问题"></a>onTouchesBegan传入参数touches的问题</h1><p>开始参考网上多点触控的代码进行实验，但是在<code>onTouchesBegan</code>回调函数上永远出问题，后来发现<code>onTouchesBegan</code>回调函数的<code>touches</code>参数永远只存了一个变量（那你用vector存什么呀啊喂！）。在进行了众多测试以及上网寻找资料（不小心还挖了个坟emmmm）后决定仔细研究下官方的Testapp源码。</p><p>原先模仿网上函数写法的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Hello::onTouchesBegan( <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cocos2d::Touch *&gt; &amp;touches,</span><br><span class="line">                            cocos2d::Event *event ) &#123;</span><br><span class="line">        <span class="keyword">if</span>( touches.size() &gt;= <span class="number">2</span> ) &#123; ... &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>这段代码的<code>touches.size()</code>的值永远是<code>1</code>。官方给出的<code>MultiTouch</code>的源代码部分如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Map&lt;<span class="keyword">int</span>, TouchPoint *&gt; s_map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MultiTouchTest::onTouchesBegan( <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Touch *&gt; &amp;touches,</span><br><span class="line">                                     Event *event ) &#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> &amp;item: touches ) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最开始看代码的时候还一脸欢喜，这官方给的例子不是明显的在说<code>touches</code>里面会存多变量的么。直到我用<code>log</code>打出来<code>touches.size()</code>后才“惊喜”的发现这值也是<code>1</code>（那你用vector干嘛呢遍历啥呢啊喂！）。</p><p>目前反推<code>onTouchesBegan</code>的设计逻辑是说一个指头的触摸激活一次<code>onTouchesBegan</code>，每个触摸的初始化单独做一次。这样的好处在于当多指相差时间很长才都按到屏幕上时，也能可以通过设计逻辑很容易的将其识别为多指操作，而不是多次单指操作。就算真的物理上是同时按住的时候也可能会给序列化处理成先后两次触摸。唯独麻烦的一点就是程序逻辑设计上要费点心思了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网上有关Cocos2d-x v3.x版本的多点触控的资料并不多，在尝试时发现了如下几个坑。跳出坑最好的办法就是去读官方给出的Testapp的源码，这样能看快的了解到官方时如何使用各种功能的，模仿和学起来都很快且很到位。如果更有能力的去多看看API和源码也是很好的学习途径。&lt;
      
    
    </summary>
    
      <category term="Cocos2d-x" scheme="https://lrscy.github.io/categories/Cocos2d-x/"/>
    
    
      <category term="Cocos2d-x" scheme="https://lrscy.github.io/tags/Cocos2d-x/"/>
    
      <category term="Android" scheme="https://lrscy.github.io/tags/Android/"/>
    
      <category term="Multi Touch" scheme="https://lrscy.github.io/tags/Multi-Touch/"/>
    
  </entry>
  
  <entry>
    <title>Cocos2d-x v3.16 Android Studio添加新类</title>
    <link href="https://lrscy.github.io/2018/02/03/Cocos2dx-3-16-Android-Studio-Add-New-Class/"/>
    <id>https://lrscy.github.io/2018/02/03/Cocos2dx-3-16-Android-Studio-Add-New-Class/</id>
    <published>2018-02-03T12:29:01.000Z</published>
    <updated>2018-02-11T13:56:58.662Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Android Studio编辑Cocos2d-x项目时，如果想添加一个Class进去，除了建立相对应的<code>.h</code>和<code>.cpp</code>以外，还需要让编译配置文件知道这个文件属于该项目。然而Android Studio 3.x版本自动同步时并不能将新类中的<code>.cpp</code>问家加入编译配置文件中。</p><p>后来发现在左侧<code>External Build Files</code>中，有个叫做<code>Android.mk</code>的文件，需要在其中的<code>LOCAL_SRC_FILES</code>变量中加入新的<code>.cpp</code>文件。即：<br><figure class="highlight mk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_SRC_FILES := <span class="variable">$(LOCAL_PATH)</span>/hellocpp/main.cpp \</span><br><span class="line">                   <span class="variable">$(LOCAL_PATH)</span>/../../../Classes/AppDelegate.cpp \</span><br><span class="line">                   <span class="variable">$(LOCAL_PATH)</span>/../../../Classes/HelloWorldScene.cpp \</span><br><span class="line">                   <span class="variable">$(LOCAL_PATH)</span>/../../../Classes/Hello.cpp</span><br></pre></td></tr></table></figure></p><p>想必大家都读得懂怎么向这个变量中加入新的文件，其中<code>Hello.cpp</code>就是我添加的新<code>.cpp</code>文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用Android Studio编辑Cocos2d-x项目时，如果想添加一个Class进去，除了建立相对应的&lt;code&gt;.h&lt;/code&gt;和&lt;code&gt;.cpp&lt;/code&gt;以外，还需要让编译配置文件知道这个文件属于该项目。然而Android Studio 3.x版本自动
      
    
    </summary>
    
      <category term="Cocos2d-x" scheme="https://lrscy.github.io/categories/Cocos2d-x/"/>
    
    
      <category term="Cocos2d-x" scheme="https://lrscy.github.io/tags/Cocos2d-x/"/>
    
      <category term="Android Studio" scheme="https://lrscy.github.io/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 16.04下TensorFlow安装</title>
    <link href="https://lrscy.github.io/2018/02/02/Ubuntu-Tensorflow-config/"/>
    <id>https://lrscy.github.io/2018/02/02/Ubuntu-Tensorflow-config/</id>
    <published>2018-02-02T05:29:40.000Z</published>
    <updated>2018-02-02T10:46:53.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>TensorFlow安装环境为<code>Ubuntu 16.04.3 LTS</code>，GPU为<code>GT 750M</code>。</p><p>假设目前已经安装好了<code>CUDA8</code>，如果没有安装请依照「<a href="/2018/02/01/Ubuntu-CUDA-Tookit-8-Install">Ubuntu 16.04下CUDA Tookit 8安装</a>」进行安装。</p><p>如果有一定英语能力的同学最好请移步<a href="https://www.tensorflow.org/install/install_linux" target="_blank" rel="noopener">官网</a>进行下载安装，尽管可能需要下科学上网。</p><h1 id="基础环境搭建"><a href="#基础环境搭建" class="headerlink" title="基础环境搭建"></a>基础环境搭建</h1><p>本文采用Virtualenv环境进行搭建，这样能将TensorFlow运行于一个分离开的Python环境下，免得今后出错时对整个系统产生影响。</p><h2 id="CUPTI环境搭建"><a href="#CUPTI环境搭建" class="headerlink" title="CUPTI环境搭建"></a>CUPTI环境搭建</h2><p>CUPTI库能够提高可以提高CUDA的性能，官方要求安装。</p><p>如果CUDA Tookit &gt;= 8.0，输入如下命令安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install cuda-command-line-tools</span><br></pre></td></tr></table></figure></p><p>并且在CUDA安装时所设定的<code>LD_LIBRARY_PATH</code>添加路径至如下状态：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/usr/<span class="built_in">local</span>/cuda/extras/CUPTI/lib64</span><br></pre></td></tr></table></figure></p><p>如果CUDA Tookit &lt;= 7.5或者上述命令无法执行，请输入如下命令安装CUPTI库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libcupti-dev</span><br></pre></td></tr></table></figure></p><h2 id="pip环境搭建"><a href="#pip环境搭建" class="headerlink" title="pip环境搭建"></a>pip环境搭建</h2><p>下面两行中选择一行执行即可，依据个人Python版本选择：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install python-pip  python-dev  python-virtualenv <span class="comment"># for Python 2.7</span></span><br><span class="line">$ sudo apt install python3-pip python3-dev python-virtualenv <span class="comment"># for Python 3.x</span></span><br></pre></td></tr></table></figure></p><p>本人选择的是<code>Python2.7</code>，因为<code>Ubuntu 16.04.3</code>默认<code>Python</code>为<code>Python 2.7</code>，改默认会影响<code>ibus-pinyin</code>（输入法）的更新和运行。</p><h2 id="Virtualenv环境搭建"><a href="#Virtualenv环境搭建" class="headerlink" title="Virtualenv环境搭建"></a>Virtualenv环境搭建</h2><p>下面两行中选择一行执行即可，依据个人Python版本选择：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ virtualenv --system-site-packages targetDirectory            <span class="comment"># for Python 2.7</span></span><br><span class="line">$ virtualenv --system-site-packages -p python3 targetDirectory <span class="comment"># for Python 3.x</span></span><br></pre></td></tr></table></figure></p><p>其中<code>targetDirectory</code>是隔离环境的根目录，需要自行设定。个人设定是<code>~/tensorflow</code>，下文暂且按照这个目录进行介绍。</p><p>至此，基础观景搭建完成。</p><h1 id="TensorFlow安装"><a href="#TensorFlow安装" class="headerlink" title="TensorFlow安装"></a>TensorFlow安装</h1><h2 id="进入Virtualenv环境"><a href="#进入Virtualenv环境" class="headerlink" title="进入Virtualenv环境"></a>进入Virtualenv环境</h2><p>输入如下命令进入Virtualenv环境：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> ~/tensorflow/bin/activate      <span class="comment"># bash, sh, ksh, or zsh</span></span><br><span class="line">$ <span class="built_in">source</span> ~/tensorflow/bin/activate.csh  <span class="comment"># csh or tcsh</span></span><br></pre></td></tr></table></figure></p><p>请依据自身<code>shell</code>环境选择，一般Ubuntu原生使用的是<code>sh</code>。</p><p>这里可以在<code>~/.bashrc</code>中输入如下命令使得命令简化：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> tensorflow=<span class="string">"source ~/tensorflow/bin/activate"</span>      <span class="comment"># bash, sh, ksh, or zsh</span></span><br><span class="line"><span class="built_in">alias</span> tensorflow=<span class="string">"source ~/tensorflow/bin/activate.csh"</span>  <span class="comment"># csh or tcsh</span></span><br></pre></td></tr></table></figure></p><p>请依据自身的<code>shell</code>环境选择第一条还是第二条。其中<code>tensorflow</code>可以自行拟定。</p><p>当编辑完后在命令行中输入如下命令使其立即生效：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></p><p>以后在命令行中输入<code>tensorflow</code>即可调出该<code>Virtualenv</code>环境。</p><p>当前环境应该如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(tensorflow) xxx@xxx:path$</span><br></pre></td></tr></table></figure></p><ol><li><code>tensorflow</code>即<code>Virtualenv</code>文件夹名称，下文按照<code>tensorflow</code>描述。</li><li><code>xxx@xxx:path</code>与未进入<code>Virtualenv</code>环境时无差别。下文中将简化描述为<code>(tensorflow) $</code></li></ol><h2 id="更新pip"><a href="#更新pip" class="headerlink" title="更新pip"></a>更新pip</h2><p>为了确保pip version &gt;= 8.1，输入如下命令更新pip：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(tensorflow) $ pip install --upgrade pip  <span class="comment"># for Python 2.7</span></span><br><span class="line">(tensorflow) $ pip3 install --upgrade pip <span class="comment"># for Python 3.x</span></span><br></pre></td></tr></table></figure></p><h2 id="安装TensorFlow"><a href="#安装TensorFlow" class="headerlink" title="安装TensorFlow"></a>安装TensorFlow</h2><p>如果系统中的<code>CUDA Tookit</code>和<code>cuDNN</code>都是最新版，请从以下四条命令中选择一个来安装TensorFlow：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(tensorflow) $ pip install --upgrade tensorflow      <span class="comment"># for Python 2.7</span></span><br><span class="line">(tensorflow) $ pip3 install --upgrade tensorflow     <span class="comment"># for Python 3.x</span></span><br><span class="line">(tensorflow) $ pip install --upgrade tensorflow-gpu  <span class="comment"># for Python 2.7 and GPU</span></span><br><span class="line">(tensorflow) $ pip3 install --upgrade tensorflow-gpu <span class="comment"># for Python 3.x and GPU</span></span><br></pre></td></tr></table></figure></p><p>前两条是仅使用CPU的版本，后两条的版本能够使用GPU。</p><p>如果系统中的<code>CUDA Tookit</code>和<code>cuDNN</code>并非最新版，按照上述安装很可能会出现问题导致重装。因此安装前请先完成如下几步：</p><ol><li>请先确定系统中的<code>cuDNN</code>和<code>CUDA Tookit</code>时想匹配的，具体版本匹配详见<a href="https://developer.nvidia.com/rdp/cudnn-download" target="_blank" rel="noopener">官网</a>。</li><li>请在<a href="https://github.com/tensorflow/tensorflow/releases" target="_blank" rel="noopener">TensorFlow的Github Release</a>中寻找符合自己<code>CUDA Tookit</code>和<code>cuDNN</code>的版本。</li><li>依照选好的版本拼凑网址。</li></ol><p>拼凑网址如下，请依据CPU以及GPU从两条中选择一条：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># for CPU only</span><br><span class="line">https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-x.x.x-cpxx-none-linux_x86_64.whl</span><br><span class="line"># for GPU support</span><br><span class="line">https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow_gpu-x.x.x-cpxx-none-linux_x86_64.whl</span><br></pre></td></tr></table></figure></p><p>其中：</p><ol><li><code>x.x.x</code>是从<code>release</code>中选择出的需要的版本。</li><li><code>cpxx</code>是本机<code>python</code>的版本，例如：<code>2.7.xx</code>为<code>27</code>，<code>3.5.xx</code>的版本为<code>35</code>，以此类推。</li><li><code>storage.googleapis.com</code>可能需要科学上网才能访问。</li></ol><p>然后进行Tensorflow的安装，输入如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(tensorflow) $ pip install yourhttpsite  <span class="comment"># for Python 2.7</span></span><br><span class="line">(tensorflow) $ pip3 install yourhttpsite <span class="comment"># for Python 3.x</span></span><br></pre></td></tr></table></figure></p><p><code>yourhttpsite</code>就是拼凑出来的网址。</p><p>如果pip提示无法从代理处下载文件，则可以先将文件从网址下载下来并存在<code>~</code>（即家目录）或者自定义目录下，然后通过如下命令安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(tensorflow) $ pip install filename  <span class="comment"># for Python 2.7</span></span><br><span class="line">(tensorflow) $ pip3 install filename <span class="comment"># for Python 3.x</span></span><br></pre></td></tr></table></figure></p><p><code>filename</code>即下载的<code>.whl</code>文件（可能需要输入完整路径）。</p><h1 id="TensorFlow的使用"><a href="#TensorFlow的使用" class="headerlink" title="TensorFlow的使用"></a>TensorFlow的使用</h1><h2 id="启动TensorFlow环境"><a href="#启动TensorFlow环境" class="headerlink" title="启动TensorFlow环境"></a>启动TensorFlow环境</h2><p>请参照<a href="#进入Virtualenv环境">进入Virtualenv环境</a>步骤进行。</p><h2 id="测试TensorFlow环境"><a href="#测试TensorFlow环境" class="headerlink" title="测试TensorFlow环境"></a>测试TensorFlow环境</h2><p>先进入TensorFlow环境，然后输入如下代码进行测试：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">hello = tf.constant(<span class="string">'Hello, TensorFlow!'</span>)</span><br><span class="line">sess = tf.Session()</span><br><span class="line">print(sess.run(hello))</span><br></pre></td></tr></table></figure></p><p>输出<code>Hello, TensorFlow!</code>且无报错即可。如果报错请参考<a href="https://www.tensorflow.org/install/install_linux#CommonInstallationProblems" target="_blank" rel="noopener">官网</a>或者上网寻找解决方案。</p><h2 id="退出TensorFlow环境"><a href="#退出TensorFlow环境" class="headerlink" title="退出TensorFlow环境"></a>退出TensorFlow环境</h2><p>在环境中输入<code>deactivate</code>即可，即：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(tensorflow) $ deactivate</span><br></pre></td></tr></table></figure></p><h1 id="TensorFlow的卸载"><a href="#TensorFlow的卸载" class="headerlink" title="TensorFlow的卸载"></a>TensorFlow的卸载</h1><p>卸载时直接将其所在的Virtualenv文件夹删除即可，命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm -rf targetDirectory</span><br></pre></td></tr></table></figure></p><p><code>targetDirectory</code>即Virtualenv环境文件夹。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;TensorFlow安装环境为&lt;code&gt;Ubuntu 16.04.3 LTS&lt;/code&gt;，GPU为&lt;code&gt;GT 750M&lt;/code
      
    
    </summary>
    
      <category term="Config" scheme="https://lrscy.github.io/categories/Config/"/>
    
    
      <category term="Ubuntu" scheme="https://lrscy.github.io/tags/Ubuntu/"/>
    
      <category term="Tensorflow" scheme="https://lrscy.github.io/tags/Tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 16.04下CUDA Tookit 8安装</title>
    <link href="https://lrscy.github.io/2018/02/01/Ubuntu-CUDA-Tookit-8-Install/"/>
    <id>https://lrscy.github.io/2018/02/01/Ubuntu-CUDA-Tookit-8-Install/</id>
    <published>2018-02-01T03:39:17.000Z</published>
    <updated>2018-02-03T04:26:07.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前一阵重做系统把之前的安装教程的博客给弄丢了，现在重写一份做记录好了。目前老环境还是要<code>CUDA Tookit 8</code>（以下简称<code>CUDA8</code>），因此目前先不安装CUDA最新的<code>CUDA9</code>了。</p><p>本教程是在Ubuntu 16.04.3 LTS上进行的，其他版本的Ubuntu系统请自行实验，目前在Ubuntu 17.10系统上实验成功。</p><p>当前假设Ubuntu系统已经安装完成，目前直接进行CUDA8的安装。</p><h1 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h1><h2 id="基础环境安装"><a href="#基础环境安装" class="headerlink" title="基础环境安装"></a>基础环境安装</h2><p>安装CUDA8需要基础的编译环境，需要检测下系统上是否安装了<code>gcc</code>或<code>g++</code>。命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -v</span><br><span class="line">$ g++ -v</span><br></pre></td></tr></table></figure></p><p>如果任意一个出现版本信息就代表安装过了。如果都没有出现版本信息，则请采用如下命令安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install build-essential</span><br></pre></td></tr></table></figure></p><p>安装完成即可，网上有说CUDA8不支持<code>g++ 5.0</code>以上的版本，目前本人没有遇上这个问题。</p><h2 id="附加环境安装"><a href="#附加环境安装" class="headerlink" title="附加环境安装"></a>附加环境安装</h2><p>有些人在上述基础环境下安装完CUDA8后会出现<code>Missing recommended library: libGLU.so</code>的提示。如果不确定当前环境想提前避免这个问题，请安装如下包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libglu1-mesa libxi-dev libxmu-dev libglu1-mesa-dev</span><br></pre></td></tr></table></figure></p><p>至此，基础环境都安装完了。</p><h1 id="NVIDIA驱动安装"><a href="#NVIDIA驱动安装" class="headerlink" title="NVIDIA驱动安装"></a>NVIDIA驱动安装</h1><p>个人强烈建议先装NVIDIA驱动，因为CUDA8自带的驱动实在是容易出问题。驱动安装详见「<a href="/2017/10/10/Ubuntu-NVIDIA-Driver-Install">Ubuntu系统NVIDIA显卡驱动安装</a>」。</p><h1 id="CUDA8安装配置"><a href="#CUDA8安装配置" class="headerlink" title="CUDA8安装配置"></a>CUDA8安装配置</h1><h2 id="CUDA8下载"><a href="#CUDA8下载" class="headerlink" title="CUDA8下载"></a>CUDA8下载</h2><p>先从<a href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="noopener">官网下载</a>CUDA的驱动。目前CUDA的最新版本是<code>CUDA9</code>，要下老版本的话请采用如下<a href="https://developer.nvidia.com/cuda-80-ga2-download-archive" target="_blank" rel="noopener">官方网址</a>，下载<code>Base Installer</code>和<code>Patch 2</code>。</p><p>个人建议先将文件都下载到家目录(<code>~</code>)底下，因为如果系统是中文环境的话，后续安装可能会出现文件夹名乱码的情况。安装完成后可以移动到自己想移动的位置。</p><h2 id="CUDA8安装"><a href="#CUDA8安装" class="headerlink" title="CUDA8安装"></a>CUDA8安装</h2><p>是否进入<code>tty1</code>环境看个人，本人之前各种重装驱动给吓怕了，不确定图形界面是否影响到了，因此直接进入了<code>tty1</code>环境进行CUDA8的安装。关闭图形界面的步骤如下：</p><ol><li>首先按住<code>Ctrl+Alt+F1</code>进入<code>tty1</code></li><li>输入用户名和密码</li><li>执行<code>sudo service lightdm stop</code>命令关闭图形界面。</li></ol><p>然后在安装文件所在目录下执行如下命令安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chmod 755 (CUDA Install File)</span><br><span class="line">$ sudo ./(CUDA Install File)</span><br></pre></td></tr></table></figure></p><p>其中<code>CUDA Install File</code>是个人CUDA安装文件的名字（包括文件后缀）。</p><p>安装关键过程如下（先后顺序记不清了）：</p><ol><li>安装过程中先阅读完一大串协议，按住<code>d</code>往下（这样跳得很快），直到最后。然后输入accept。</li><li>会询问是否安装<code>NVIDIA DRIVER</code>，输入<code>n</code>。</li><li>询问是否安装<code>OPENGL</code>时输入<code>n</code>。（记得有这个问题的，这里是个大坑！！）</li><li>其他默认选择<code>y</code>或者<code>空着</code>（就是直接按回车）就行。</li></ol><p>到最后可能会出现<code>INCOMPLETE INSTALL</code>，这里不用管。这是因为你没装它的驱动而已。如果出现<code>Missing recommended library: libGLU.so</code>的提示，请参考<a href="#附加环境安装">附加环境安装</a></p><p>等一切都安装好后重启即可。</p><h2 id="补丁安装"><a href="#补丁安装" class="headerlink" title="补丁安装"></a>补丁安装</h2><p>是否进入<code>tty1</code>环境依旧看个人，具体参考上一节开头。</p><p>安装时执行如下命令安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chmod 755 (CUDA Patch File)</span><br><span class="line">$ sudo ./(CUDA Patch File)</span><br></pre></td></tr></table></figure></p><p>其中<code>CUDA Patch File</code>是之前下载的CUDA8的补丁文件<code>Patch 2</code>。安装过程和前一节类似，基本上直接一路默认就行。</p><p>等一切安装完了后重启即可。</p><h2 id="环境设置"><a href="#环境设置" class="headerlink" title="环境设置"></a>环境设置</h2><p>个人习惯在<code>/etc/profile.d</code>下设置环境变量。先进入该文件夹，然后执行如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo touch cuda.sh</span><br><span class="line">$ sudo vim cuda.sh</span><br></pre></td></tr></table></figure></p><p>这里<code>vim</code>可以换成<code>gedit</code>或者其他熟悉的编辑器。如果不熟悉<code>vim</code>的同学无意间进去了，输入<code>:q</code>退出<code>vim</code>。</p><p>在编辑器中输入如下文字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export CUDA_HOME=/usr/local/cuda-8.0</span><br><span class="line">export PATH=$PATH:/usr/local/cuda-8.0/bin</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda-8.0/lib64</span><br></pre></td></tr></table></figure></p><p>然后保存重启即可。</p><h2 id="cuDNN安装"><a href="#cuDNN安装" class="headerlink" title="cuDNN安装"></a>cuDNN安装</h2><p><code>cuDNN</code>是个GPU加速库，能为深度学习网络的计算加速。在<a href="https://developer.nvidia.com/rdp/cudnn-download" target="_blank" rel="noopener">官网</a>下载。下载前可能需要先注册<code>NVIDIA DEVELOPER</code>。注册过程很简单，注册完成后选择支持<code>CUDA8.0</code>的<code>cuDNN</code>下载即可。</p><p>在下载目录解压后进入<code>cuda</code>文件夹，这里会见到<code>include</code>和<code>lib64</code>两个文件夹。这里建议在命令行下执行，因为会用到<code>sudo</code>进行暂时的root权限申请。输入如下命令进行安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cp include/cudnn.h /usr/<span class="built_in">local</span>/cuda/include</span><br><span class="line">$ sudo cp lib64/libcudnn* /usr/<span class="built_in">local</span>/cuda/lib64</span><br></pre></td></tr></table></figure></p><p>然后进入<code>/usr/local/cuda/lib64</code>文件夹中，执行如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm libcudnn.so libcudnn.so.6</span><br><span class="line">$ sudo ln -s libcudnn.so.6.0.20 libcudnn.so.6</span><br><span class="line">$ sudo ln -s libcudnn.so.6 libcudnn.so</span><br><span class="line">$ sudo ldconfig</span><br></pre></td></tr></table></figure></p><p>这里<code>.6</code>和<code>.6.0.20</code>是下载的cuDNN的版本号，请依据个人下载的实际版本进行修改。</p><p>至此，cuDNN已经安装完成。</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>至此，整个CUDA Tookit 8的所有安装过程就完成了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前一阵重做系统把之前的安装教程的博客给弄丢了，现在重写一份做记录好了。目前老环境还是要&lt;code&gt;CUDA Tookit 8&lt;/code&gt;（
      
    
    </summary>
    
      <category term="Config" scheme="https://lrscy.github.io/categories/Config/"/>
    
    
      <category term="Ubuntu" scheme="https://lrscy.github.io/tags/Ubuntu/"/>
    
      <category term="CUDA" scheme="https://lrscy.github.io/tags/CUDA/"/>
    
  </entry>
  
  <entry>
    <title>Cocos2d-x v3.16 屏幕显示偏移</title>
    <link href="https://lrscy.github.io/2018/01/26/Cocos2dx-3-16-Display-Offset/"/>
    <id>https://lrscy.github.io/2018/01/26/Cocos2dx-3-16-Display-Offset/</id>
    <published>2018-01-26T12:28:36.000Z</published>
    <updated>2018-02-11T13:56:47.978Z</updated>
    
    <content type="html"><![CDATA[<p>在v3.16前，屏幕上显示Sprites, Nodes都是直接使用Director类获取可视区大小并直接在上面定位Nodes的，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> size = Director::getInstance()-&gt;getVisibleSize();</span><br><span class="line"><span class="keyword">auto</span> sprite = Sprite::create( <span class="string">"HelloWorld.png"</span> );</span><br><span class="line">sprite.setPosition( size.width / <span class="number">2</span>, size.height / <span class="number">2</span> );</span><br></pre></td></tr></table></figure></p><p>目前不知道时从哪个版本开始的，直接使用上述代码会导致<code>sprite</code>下偏移(沿y轴)一定量但无左右偏移(沿x轴)。查找资料未果后看Helloworld样例，发现其用到了Director类中另一个变量纠正这个问题：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vec2 origin = Director::getInstance()-&gt;getVisibleOrigin();</span><br></pre></td></tr></table></figure></p><p>这里<code>origin</code>是真正的屏幕左下角的位置，所有屏幕上的显示的图像都要依据这个坐标进行调整。也就是说上述代码要改成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> size = Director::getInstance()-&gt;getVisibleSize();</span><br><span class="line">Vec2 origin = Director::getInstance()-&gt;getVisibleOrigin();</span><br><span class="line"><span class="keyword">auto</span> sprite = Sprite::create( <span class="string">"HelloWorld.png"</span> );</span><br><span class="line">sprite.setPosition( origin.x + size.width / <span class="number">2</span>, origin.y + size.height / <span class="number">2</span> );</span><br></pre></td></tr></table></figure></p><p>这时，屏幕偏移问题解决了，<code>sprite</code>也在屏幕的真正的正中央。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在v3.16前，屏幕上显示Sprites, Nodes都是直接使用Director类获取可视区大小并直接在上面定位Nodes的，例如：&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
      <category term="Cocos2d-x" scheme="https://lrscy.github.io/categories/Cocos2d-x/"/>
    
    
      <category term="Cocos2d-x" scheme="https://lrscy.github.io/tags/Cocos2d-x/"/>
    
      <category term="Display Offset" scheme="https://lrscy.github.io/tags/Display-Offset/"/>
    
  </entry>
  
  <entry>
    <title>Cocos2d-x v3.16踩过的坑</title>
    <link href="https://lrscy.github.io/2018/01/26/Cocos2dx-3-16-Problems/"/>
    <id>https://lrscy.github.io/2018/01/26/Cocos2dx-3-16-Problems/</id>
    <published>2018-01-26T08:35:23.000Z</published>
    <updated>2018-02-11T13:58:01.623Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近刚碰关于Cocos2d-x的知识，也上网查过很多资料，但是很少有讲最新v3.16的博客。因此在此记录下使用v3.16时候遇上的坑。且会不定期更新该篇博客。</p><p>UPDATE 2018.02.11:之前是写在一起的，但是看起来太乱，就拆分到各自单独篇章中去了，这里只做个目录。</p><ol><li><a href="/2018/01/26/Cocos2dx-3-16-Display-Offset">屏幕显示偏移</a></li><li><a href="/2018/02/03/Cocos2dx-3-16-Android-Studio-Add-New-Class">Android Studio添加新类</a></li><li><a href="/2018/02/11/Cocos2dx-3-16-Android-Multi-Touch">多点触控</a></li><li><a href="/2018/02/11/Cocos2dx-3-16-Y-axis-Flip">Y轴翻转</a></li></ol><p>To be continue…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近刚碰关于Cocos2d-x的知识，也上网查过很多资料，但是很少有讲最新v3.16的博客。因此在此记录下使用v3.16时候遇上的坑。且会不
      
    
    </summary>
    
      <category term="Cocos2d-x" scheme="https://lrscy.github.io/categories/Cocos2d-x/"/>
    
    
      <category term="Cocos2d-x" scheme="https://lrscy.github.io/tags/Cocos2d-x/"/>
    
      <category term="Android Studio" scheme="https://lrscy.github.io/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>在Github上备份Hexo博客</title>
    <link href="https://lrscy.github.io/2018/01/26/Hexo-Github-Backup/"/>
    <id>https://lrscy.github.io/2018/01/26/Hexo-Github-Backup/</id>
    <published>2018-01-26T04:57:56.000Z</published>
    <updated>2018-02-03T04:25:38.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于之前忘记备份Hexo博客的markdown文件，在重做系统时候还忘记备份博客了，导致现在不得不重新从网页上扒下来之前的文章重新写一遍，十分耗费精力。因此在网上找了下如何备份Hexo博客，在此记录下。</p><p>目前假设Git和Github环境已经配置好了，如果没有配置好详见「<a href="/2017/05/01/Ubuntu-Github-config">Ubuntu16.04下Github配置</a>」。<br>Git相关操作请参考<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的Git教程</a>。</p><h1 id="备份博客"><a href="#备份博客" class="headerlink" title="备份博客"></a>备份博客</h1><p>目前假设本地Hexo博客已经初始化，如果没有配置好Hexo博客详见「<a href="/2017/11/10/Ubuntu-Github-io-config-Hexo">Ubuntu16.04下从零起步搭建配置github.io博客————Hexo</a>」。</p><h2 id="创建新分支"><a href="#创建新分支" class="headerlink" title="创建新分支"></a>创建新分支</h2><p>在Github.io上建立博客时已经开了一个新仓库了，如果再开另一个仓库存放源代码有点浪费，因此采用建立新分支的方法备份博客。</p><p>虽然理论上什么时候创建新分支来备份都可以，但是还是建议在建立博客的时候就创建备份分支。（然而我中途才想起来-.-）</p><p>本地Git建立新分支命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b BRANCHNAME</span><br></pre></td></tr></table></figure></p><p><code>BRANCHNAME</code>是自定义的新分支的名字，建议起为<code>hexo</code>。</p><h2 id="建立-gitignore"><a href="#建立-gitignore" class="headerlink" title="建立.gitignore"></a>建立.gitignore</h2><p>建立<code>.gitignore</code>文件将不需要备份的文件屏蔽。个人的<code>.gitignore</code>文件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure></p><h2 id="在Github上备份"><a href="#在Github上备份" class="headerlink" title="在Github上备份"></a>在Github上备份</h2><p>通过如下命令将本地文件备份到Github上。</p><p>假设目前在hexo博客的根目录下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"Backup"</span></span><br><span class="line">$ git push origin hexo</span><br></pre></td></tr></table></figure></p><p>这样就备份完博客了且在Github上能看到两个分支(<code>master</code>和<code>hexo</code>)。</p><h2 id="设置默认分支"><a href="#设置默认分支" class="headerlink" title="设置默认分支"></a>设置默认分支</h2><p>在Github上你的github.io仓库中设置默认分支为<code>hexo</code>。这样有助于之后恢复博客。<code>master</code>分支时默认的博客静态页面分支，在之后恢复博客的时候并不需要。</p><h2 id="个人备份习惯"><a href="#个人备份习惯" class="headerlink" title="个人备份习惯"></a>个人备份习惯</h2><p>个人而言习惯于先备份文件再生成博客。即先执行<code>git add .</code>,<code>git commit -m &quot;Backup&quot;</code>,<code>git push origin hexo</code>将博客备份完成，然后执行<code>hexo g -d</code>发布博客。</p><h1 id="恢复博客"><a href="#恢复博客" class="headerlink" title="恢复博客"></a>恢复博客</h1><p>目前假设本地Hexo博客基础环境已经搭好，如果没有配置好Hexo博客基础环境详见「<a href="/2017/11/10/Ubuntu-Github-io-config-Hexo#基础环境搭建">Ubuntu16.04下从零起步搭建配置github.io博客————Hexo</a>」。</p><h2 id="克隆项目到本地"><a href="#克隆项目到本地" class="headerlink" title="克隆项目到本地"></a>克隆项目到本地</h2><p>输入下列命令克隆博客必须文件(<code>hexo</code>分支)：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/yourgithubname/yourgithubname.github.io</span><br></pre></td></tr></table></figure></p><h2 id="恢复博客-1"><a href="#恢复博客-1" class="headerlink" title="恢复博客"></a>恢复博客</h2><p>在克隆的那个文件夹下输入如下命令恢复博客：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo</span><br><span class="line">$ npm install</span><br><span class="line">$ npm install hexo-deployer-git</span><br></pre></td></tr></table></figure></p><p>在此不需要执行<code>hexo init</code>这条指令，因为不是从零搭建起新博客。</p><p>完成喵～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;由于之前忘记备份Hexo博客的markdown文件，在重做系统时候还忘记备份博客了，导致现在不得不重新从网页上扒下来之前的文章重新写一遍，十
      
    
    </summary>
    
      <category term="Config" scheme="https://lrscy.github.io/categories/Config/"/>
    
    
      <category term="Hexo" scheme="https://lrscy.github.io/tags/Hexo/"/>
    
      <category term="Github" scheme="https://lrscy.github.io/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>Hexo中图片插入问题</title>
    <link href="https://lrscy.github.io/2018/01/26/Hexo-Picture-Insert/"/>
    <id>https://lrscy.github.io/2018/01/26/Hexo-Picture-Insert/</id>
    <published>2018-01-26T01:59:05.000Z</published>
    <updated>2018-02-03T04:25:47.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在用Hexo搭建博客时有时需要插入图片，但是原生Hexo对图片管理的支持不是很好。此篇博客记录利用插件和Hexo的配置解决这个问题。</p><h1 id="config-yml配置更改"><a href="#config-yml配置更改" class="headerlink" title="_config.yml配置更改"></a>_config.yml配置更改</h1><p>在Hexo根目录下，<code>_config.yml</code>文件管理整个Hexo的配置设置。其中要开启<code>post_asset_folder</code>，即：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>更改完成后，每新生成一片文章，就会在同级目录下生成一个名字相同的相对应的文件夹。图片存在该文件夹下即可。</p><h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><p>由于原生Hexo资源文件夹在生成真正博客时地址转换有问题，需要安装插件进行修正。执行如下命令安装插件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure></p><p>当安装完成后就可以在写Markdown时很容易的使用资源文件夹下的图片了。</p><h1 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h1><p>在插入图片时只要使用如下Markdown语法即可<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](文章名字/图片名字.后缀)</span><br></pre></td></tr></table></figure></p><p>不知道我是不是因为在<code>_config.yml</code>中开启了<code>relative_link</code>，我采用如下方式插入图片：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](图片名字.后缀)</span><br></pre></td></tr></table></figure></p><p>这点以后再探究好了喵～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在用Hexo搭建博客时有时需要插入图片，但是原生Hexo对图片管理的支持不是很好。此篇博客记录利用插件和Hexo的配置解决这个问题。&lt;/p&gt;
      
    
    </summary>
    
      <category term="Config" scheme="https://lrscy.github.io/categories/Config/"/>
    
    
      <category term="Hexo" scheme="https://lrscy.github.io/tags/Hexo/"/>
    
      <category term="Markdown" scheme="https://lrscy.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Markdown中MathJax的用法</title>
    <link href="https://lrscy.github.io/2018/01/26/Markdown-MathJax-Usage/"/>
    <id>https://lrscy.github.io/2018/01/26/Markdown-MathJax-Usage/</id>
    <published>2018-01-26T01:25:33.000Z</published>
    <updated>2018-02-03T04:25:52.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Markdown和MathJax在一些语法上有交集，在此记录下两者有冲突的地方，作为今后的提醒。</p><h1 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h1><p>在Markdwon中，下划线代表斜体，例如：<code>_a_</code>的效果既是<em>a</em>。在MathJax中，下划线代表下标，例如：`$a\_2$’的效果既是$a_2$。</p><p>在Markdown解析过程中，可能会出现错误解析MathJax下划线的事情。因此在MathJax公式中要将<code>_</code>替换成<code>\_</code>，将下划线转义成真正的下划线符号。</p><h1 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a>多行公式</h1><p>在MathJax中，<code>\\</code>代表换行。在Markdown中，<code>\\</code>代表将转义字符<code>\</code>转义成真正的<code>\</code>字符，因此写<code>\\</code>后被解析出来时只有一个<code>\</code>，因此无法达成换行效果。因此在写换行时连续输入三个<code>\</code>即<code>\\\</code>即可达成换行要求。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;align&#125;</span><br><span class="line">r\_t &amp;= \sigma(W\_rx\_t + Urh\_&#123;t-1&#125; + b\_r) \\\</span><br><span class="line">u\_t &amp;= \sigma(W\_ux\_t + r\_t \odot (U\_uh\_&#123;t-1&#125;) + b\_u) \\\</span><br><span class="line">h\_t &amp;= u\_t \odot h\_&#123;t-1&#125; + (1-u\_t) \odot \tanh(Wx\_t + r\_t \odot (U\_uh\_&#123;t-1&#125;) + b)</span><br><span class="line">\end&#123;align&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果如下：</p><p>$$<br>\begin{align}<br>r_t &amp;= \sigma(W_rx_t + Urh_{t-1} + b_r) \\<br>u_t &amp;= \sigma(W_ux_t + r_t \odot (U_uh_{t-1}) + b_u) \\<br>h_t &amp;= u_t \odot h_{t-1} + (1-u_t) \odot \tanh(Wx_t + r_t \odot (U_uh_{t-1}) + b)<br>\end{align}<br>$$</p><p>目前只踩到了这些坑，今后再有新坑再往后填入。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Markdown和MathJax在一些语法上有交集，在此记录下两者有冲突的地方，作为今后的提醒。&lt;/p&gt;
&lt;h1 id=&quot;下划线&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="Usage" scheme="https://lrscy.github.io/categories/Usage/"/>
    
    
      <category term="Markdown" scheme="https://lrscy.github.io/tags/Markdown/"/>
    
      <category term="MathJax" scheme="https://lrscy.github.io/tags/MathJax/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 16.04下从零起步搭建配置github.io博客——Hexo</title>
    <link href="https://lrscy.github.io/2017/11/10/Ubuntu-Github-io-config-Hexo/"/>
    <id>https://lrscy.github.io/2017/11/10/Ubuntu-Github-io-config-Hexo/</id>
    <published>2017-11-09T16:00:00.000Z</published>
    <updated>2018-02-02T08:57:00.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文利用Github io和Hexo搭建静态博客。主题更换等问题请到Hexo Theme里寻找并替换。</p><p>继上次用Jekyll搭建博客后，又忙了很多其他事情，接触到了Hexo。因此决定将博客从Jekyll换到Hexo。</p><p>本人是个前端小白，按照网上众多教程搭建时候依旧踩了很多坑，在此记录下来以便有相同问题的同学可以快速解决。</p><p>搭建Github io静态博客所需基础之基础的知识如下：</p><ul><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">Git</a></li><li><a href="https://github.com/" target="_blank" rel="noopener">Github</a></li><li><a href="http://wowubuntu.com/markdown/" target="_blank" rel="noopener">Markdown</a></li><li><a href="https://hexo.io/zh-cn/index.html" target="_blank" rel="noopener">Hexo</a></li></ul><p>本文是在Ubuntu 17.04环境下配置的，如果使用其他操作系统请自行查找对应命令或者解决方案。</p><p>以下代码区域，带有<code>$</code>打头的表示需要在控制台（终端或称命令行）下面执行（不包括<code>$</code>符号）。如果出现权限不足提示请在命令最前面加上<code>sudo</code>再执行。</p><p>本文几乎所有命令都可以直接拷到控制台（终端或称命令行）内直接执行而不用理解其具体含义（除非特殊表明需要修改），但是强烈不建议这么做！！！</p><p>我是基于Hexo模板搭建的博客，所以不会讲如何从零手敲出一个博客样式出来，但会比较详细的讲模板中哪里需要修改。</p><h1 id="基础环境搭建"><a href="#基础环境搭建" class="headerlink" title="基础环境搭建"></a>基础环境搭建</h1><h2 id="Git-Github-SSH配置"><a href="#Git-Github-SSH配置" class="headerlink" title="Git/Github/SSH配置"></a>Git/Github/SSH配置</h2><p>详见我的博客「<a href="/2017/05/01/Ubuntu-Github-config">Ubuntu16.04下Github配置</a>」。</p><h2 id="Node-js安装"><a href="#Node-js安装" class="headerlink" title="Node.js安装"></a>Node.js安装</h2><p>安装Hexo前需要安装Node.js，本人安装的是Node.js 8。</p><p>对于Ubuntu系列系统，执行以下两个命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -</span><br><span class="line">$ sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure></p><p>如果系统中没有安装<code>curl</code>，执行下述命令安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install curl</span><br></pre></td></tr></table></figure></p><p>安装完成后需要检查下<code>node</code>和<code>npm</code>的版本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">$ npm -v</span><br></pre></td></tr></table></figure></p><p>分别显示出版本号就算安装完成了～<br>本站搭建时<code>node</code>版本为<code>v8.9.1</code>，<code>npm</code>版本为<code>5.5.1</code>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://nodejs.org/en/download/package-manager/#debian-and-ubuntu-based-linux-distributions" target="_blank" rel="noopener">Node.js官网</a>。</p><h1 id="Hexo本地建站"><a href="#Hexo本地建站" class="headerlink" title="Hexo本地建站"></a>Hexo本地建站</h1><h2 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h2><p>Hexo安装非常简单，上述环境搭建好后只需执行以下命令即可：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p><p>本站搭建时Hexo的版本是3.4.0。</p><h2 id="Hexo本地建站-1"><a href="#Hexo本地建站-1" class="headerlink" title="Hexo本地建站"></a>Hexo本地建站</h2><p>首先通过终端进入希望建站的文件夹内（例如<code>~/Hexo</code>），执行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure></p><p>该命令要求建站文件夹是全空的文件夹。如果之前在该文件夹内建立了git等文件（夹），请先移出文件夹，建站完成后再移回来。</p><p>下述命令会在该文件夹下建立所有需要的文件。接下来安装依赖包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p><p>至此，Hexo本地博客已经搭建完成。对，你没看错～</p><p>然后执行以下命令来浏览本地站点<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></p><ul><li><code>hexo generate</code>是用来编译生成站点，每次对站点内容编辑后都要进行该项操作。可以简化为<code>hexo g</code>。</li><li><code>hexo server</code>是用来启动本地站点，执行后即可在浏览器中输入localhost:4000查看。可以简化为<code>hexo s</code>。</li></ul><h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo 官方文档</a></p><h1 id="Github-io部署博客"><a href="#Github-io部署博客" class="headerlink" title="Github io部署博客"></a>Github io部署博客</h1><h2 id="config-yml参数设置"><a href="#config-yml参数设置" class="headerlink" title="_config.yml参数设置"></a>_config.yml参数设置</h2><p>部署配置在_config.yml文件的末尾，默认样子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">type:</span><br><span class="line">repo:</span><br></pre></td></tr></table></figure></p><p>修改后如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: http://github.com/xxx/xxx.github.io.git(xxx是Github账户名称)</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure></p><ul><li>由于是部署到Github中，所以<code>type</code>是<code>git</code>。</li><li><code>repo</code>是指Github对应仓库的SSH地址。点击该仓库页面右侧绿色download，里面的地址就是<code>SSH</code>地址。</li><li><code>branch</code>是指上传到Github的哪个分支，如果没特殊需求选择<code>master</code>就可以。特殊需求请自行填写上传哪个branch。</li></ul><h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><p>为了部署到Github上，需要安装hexo-deployer-git插件，命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><h2 id="最终部署"><a href="#最终部署" class="headerlink" title="最终部署"></a>最终部署</h2><p>最终部署需要输入以下两个命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></p><ul><li><code>hexo generate</code>同上。</li><li><code>hexo deploy</code>将hexo部署到Github io上。可以简化为<code>hexo d</code>。</li></ul><p>上传后需要等待几分钟，然后就可以在浏览器中输入<code>xxx.github.io</code>来欣赏了喵～</p><h2 id="参考资料-2"><a href="#参考资料-2" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://hexo.io/zh-cn/docs/deployment.html" target="_blank" rel="noopener">Hexo 部署</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文利用Github io和Hexo搭建静态博客。主题更换等问题请到Hexo Theme里寻找并替换。&lt;/p&gt;
&lt;p&gt;继上次用Jekyll搭
      
    
    </summary>
    
      <category term="Config" scheme="https://lrscy.github.io/categories/Config/"/>
    
    
      <category term="Hexo" scheme="https://lrscy.github.io/tags/Hexo/"/>
    
      <category term="Ubuntu" scheme="https://lrscy.github.io/tags/Ubuntu/"/>
    
      <category term="Github.io" scheme="https://lrscy.github.io/tags/Github-io/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu系统NVIDIA显卡驱动安装</title>
    <link href="https://lrscy.github.io/2017/10/10/Ubuntu-NVIDIA-Driver-Install/"/>
    <id>https://lrscy.github.io/2017/10/10/Ubuntu-NVIDIA-Driver-Install/</id>
    <published>2017-10-09T16:00:00.000Z</published>
    <updated>2018-02-02T08:58:27.624Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是在Ubuntu 17.04系统上安装NVIDIA驱动。</p><p>在Ubuntu 16.04 LTS上安装驱动时是从<a href="https://www.geforce.cn/drivers" target="_blank" rel="noopener">NVIDIA 官网</a>上下载.run文件然后按照提示安装，但是在Ubuntu 17.04上并不成功。因此寻找到了一种更为简便的方法，记录在此。</p><p>如果要在本机安装NVIDIA Driver的话请先用手机等设备照下关键步骤然后再执行。</p><h1 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h1><h2 id="查找合适的驱动"><a href="#查找合适的驱动" class="headerlink" title="查找合适的驱动"></a>查找合适的驱动</h2><p>在<a href="https://www.geforce.cn/drivers" target="_blank" rel="noopener">NVIDIA 官网</a>上寻找合适的驱动，并记住其版本号。例如，384.98的版本号是384。</p><h2 id="关闭图形界面"><a href="#关闭图形界面" class="headerlink" title="关闭图形界面"></a>关闭图形界面</h2><p>首先按住<code>Ctrl+Alt+F1</code>进入<code>tty1</code>模式，然后输入如下代码关闭图形界面（X Server）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo stop lightdm</span><br></pre></td></tr></table></figure></p><p><code>lightdm</code>指的是图形界面服务</p><h2 id="卸载之前的NVIDIA显卡驱动"><a href="#卸载之前的NVIDIA显卡驱动" class="headerlink" title="卸载之前的NVIDIA显卡驱动"></a>卸载之前的NVIDIA显卡驱动</h2><p>如果之前有尝试过其他驱动，则需要将其卸载步骤如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt remove nvidia-*</span><br></pre></td></tr></table></figure></p><p>如果采用的是.run文件安装的系统请采用如下命令卸载：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ./NVIDIA-*.run --uninstall</span><br></pre></td></tr></table></figure></p><p>这里<code>NVIDIA-*.run</code>是下载的.run文件全名。</p><h1 id="安装NVIDIA显卡驱动"><a href="#安装NVIDIA显卡驱动" class="headerlink" title="安装NVIDIA显卡驱动"></a>安装NVIDIA显卡驱动</h1><p>因为无法通过.run方式安装驱动，因此采用从第三方源的方式安装驱动。</p><h2 id="添加第三方源"><a href="#添加第三方源" class="headerlink" title="添加第三方源"></a>添加第三方源</h2><p>这次采用的是<code>mamarley</code>源，添加该源的命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository ppa:mamarley/nvidia</span><br></pre></td></tr></table></figure></p><p>然后进行更新源<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update</span><br></pre></td></tr></table></figure></p><h2 id="安装NVIDIA显卡驱动-1"><a href="#安装NVIDIA显卡驱动-1" class="headerlink" title="安装NVIDIA显卡驱动"></a>安装NVIDIA显卡驱动</h2><p>在添加好第三方源后采用apt方式安装，命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install nvidia-384</span><br></pre></td></tr></table></figure></p><p>本文安装的是384版本，请按照个人不同的需求输入合适的驱动版本号。</p><p>至此，驱动已经安装完成，但是请不要立即启动<code>lightdm</code>服务。请先输入以下命令重启系统：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ reboot</span><br></pre></td></tr></table></figure></p><h2 id="检查安装结果"><a href="#检查安装结果" class="headerlink" title="检查安装结果"></a>检查安装结果</h2><p>在命令行输入如下结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nvidia-smi</span><br><span class="line">$ nvidia-settings</span><br></pre></td></tr></table></figure></p><p>输入<code>nvidia-smi</code>命令后输出一个表格即为正常。<br>输入<code>nvidia-settings</code>出现下图即为正常。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="NVIDIA-X-Server-Settings.png" alt="NVIDIA-X-Server-Settings" title="">                </div>                <div class="image-caption">NVIDIA-X-Server-Settings</div>            </figure></p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>如果安装显卡后出现循环登录不进入桌面的情况请执行“<a href="#安装准备">安装准备</a>”中的“<a href="#关闭图形界面">关闭图形界面</a>”和“<a href="#卸载之前的NVIDIA显卡驱动">卸载之前的NVIDIA显卡驱动</a>”。</p><h1 id="卸载驱动"><a href="#卸载驱动" class="headerlink" title="卸载驱动"></a>卸载驱动</h1><p>卸载驱动请按照“卸载之前NVIDIA驱动”所述内容进行卸载并重启。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文是在Ubuntu 17.04系统上安装NVIDIA驱动。&lt;/p&gt;
&lt;p&gt;在Ubuntu 16.04 LTS上安装驱动时是从&lt;a href
      
    
    </summary>
    
      <category term="Config" scheme="https://lrscy.github.io/categories/Config/"/>
    
    
      <category term="Ubuntu" scheme="https://lrscy.github.io/tags/Ubuntu/"/>
    
      <category term="NVIDIA" scheme="https://lrscy.github.io/tags/NVIDIA/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 16.04下(多)SSH配置</title>
    <link href="https://lrscy.github.io/2017/05/02/Ubuntu-SSH-config/"/>
    <id>https://lrscy.github.io/2017/05/02/Ubuntu-SSH-config/</id>
    <published>2017-05-01T16:00:00.000Z</published>
    <updated>2018-02-02T08:59:02.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h1><p>本文记录了我配置同机多SSH时候的全过程。<br>本文是在Ubuntu 16.04 LTS下配置的，如果使用其他操作系统请自行查找对应命令或解决方案。<br>以下代码区域，带有<code>$</code>打头的表示需要在控制台（终端或称命令行）下面执行（不包括<code>$</code>符号）</p><h1 id="SSH安装"><a href="#SSH安装" class="headerlink" title="SSH安装"></a>SSH安装</h1><p>Ubuntu 16.04 LTS自带openssh客户端，但是不带openssh服务器端。如果需要<code>ssh localhost</code>连接本地，那么需要安装<code>openssh-server</code>，命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install openssh-server</span><br></pre></td></tr></table></figure></p><p>如果你的机器上没有装客户端的话需要执行以下命令安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install openssh-client</span><br></pre></td></tr></table></figure></p><p>至此，基础环境已经安装完了。</p><h1 id="单SSH配置"><a href="#单SSH配置" class="headerlink" title="单SSH配置"></a>单SSH配置</h1><p>此节操作只适用于只需要免密码登录一个远程服务器的同学，如果你需要同时SSH远程登录多个服务器，那么请直接跳至下一节。</p><p>对于单SSH配置，你只需要输入以下命令即可，此时为默认状态，你的个人信息不会被加入进去：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa</span><br></pre></td></tr></table></figure></p><p>如果你需要将个人信息（如邮箱）加入进去（比如远程访问Github时），那么请执行如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"youraddress@youremail.com"</span></span><br></pre></td></tr></table></figure></p><p>这里有几点需要注意的：</p><ol><li><code>-C</code>中的C是大写字母</li><li><code>youraddress@youremail.com</code>是你Github的注册邮箱</li></ol><p>对于上述两条命令，如果你远程登录时候需要设置密码，那么请在其提示时候输入密码。然后一路回车即可。 然后你会发现在你的家目录（<code>~</code>或者<code>/home/username/</code>）下多了一个叫做<code>.ssh</code>的文件夹，里面有两个文件<code>id_rsa</code>和<code>id_rsa.pub</code>。这两个就是SSH生成的文件，你需要将公钥传给远程服务器（Github相关问题详见<a href="/2017/05/01/Ubuntu-Github-config">Ubuntu16.04下Github配置</a>博文），然后就可以免密码远程登录了。</p><h1 id="多SSH配置"><a href="#多SSH配置" class="headerlink" title="多SSH配置"></a>多SSH配置</h1><h2 id="建立不同的SSH配置文件"><a href="#建立不同的SSH配置文件" class="headerlink" title="建立不同的SSH配置文件"></a>建立不同的SSH配置文件</h2><p>首先你需要在家目录（<code>~</code>或者<code>/home/username/</code>）下建立一个<code>.ssh</code>文件夹，命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir .ssh</span><br></pre></td></tr></table></figure></p><p>然后进入该文件夹（建议进入）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh</span><br></pre></td></tr></table></figure></p><p>在该文件夹下，输入以下命令，后面我会介绍每个参数的作用：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -f ~/.ssh/id_rsa.blabla</span><br></pre></td></tr></table></figure></p><p>如果你需要将个人信息（如邮箱）加入进去（比如远程访问Github时），那么请执行如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -f ~/.ssh/id_rsa.blabla -C <span class="string">"youraddress@youremail.com"</span></span><br></pre></td></tr></table></figure></p><p>下面我们来分析下这两个命令。</p><ol><li><code>-t</code> <code>rsa</code>是指定你的加密算法。</li><li><code>-f</code>是指定你的文件存储位置，我建议存在<code>~/.ssh</code>文件夹中。文件明明我建议按照我的格式写，<code>blabla</code>是该SSH配置文件的用途，比如<code>.github</code>, <code>.localhost</code>之类的。</li><li><code>-C</code>注意这里C是大写字母。这里填写你的邮箱地址（顺便提一句配置Github时一定要填写你的注册邮箱，详见<a href="/2017/05/01/Ubuntu-Github-config">Ubuntu16.04下Github配置</a>）。</li></ol><h2 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h2><p>因为你有多对SSH配置文件（<code>.blabla</code>和<code>.blabla.pub</code>是一对私钥和公钥），所以在远程登陆时，系统需要知道你需要将哪份私钥和远程的公钥进行匹配。所以你需要一个索引文件<code>config</code>。输入如下命令建立该文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch config</span><br></pre></td></tr></table></figure></p><p>文件格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host name</span><br><span class="line">    HostName hostname</span><br><span class="line">    User username</span><br><span class="line">    IdentityFile filepath</span><br></pre></td></tr></table></figure></p><p>一个config文件中可以有多个上述结构，每个结构之间建议用一个空行隔开。下面解析下这个结构。</p><ol><li><code>Host</code>就是个名字，每个结构之间不得重复</li><li><code>HostName</code>是远程主机的域名，比如github.com, localhost之类或者是一个固定的IP地址。</li><li><code>User</code>就是你登录该远程主机的用户名。</li><li><code>IdentityFile</code>就是对应该主机的私钥的文件路径。依上述教程，应为<code>~/.ssh/id_rsa.blabla</code>。</li></ol><h1 id="登录localhost"><a href="#登录localhost" class="headerlink" title="登录localhost"></a>登录localhost</h1><p>在配置软件环境时，有软件需要免密码登录<code>localhost</code>，也就是免密码登录本机。此时，你需要在<code>.ssh</code>目录下建立<code>authorized_keys</code>文件，命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch authorized_keys</span><br></pre></td></tr></table></figure></p><p>建立此文件的目的是存储已知的SSH公钥信息。此时你需要将localhost的公钥复制进来。<br>如果你是单SSH配置，则需要把<code>id_rsa.pub</code>文件复制进来。命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat id_rsa.pub &gt;&gt; authorized_keys</span><br></pre></td></tr></table></figure></p><p>如果你是多SSH配置，依上述教程，你需要把<code>id_rsa.localhost.pub</code>复制进来，命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat id_rsa.localhost.pub &gt;&gt; authorized_keys</span><br></pre></td></tr></table></figure></p><p>然后你就可以免密码登录localhost了。另外，如果需要添加其他已知SSH公钥的话，直接往<code>authorized_keys</code>中添加即可。</p><h1 id="常见提示及应对方法"><a href="#常见提示及应对方法" class="headerlink" title="常见提示及应对方法"></a>常见提示及应对方法</h1><h2 id="第一次登录"><a href="#第一次登录" class="headerlink" title="第一次登录"></a>第一次登录</h2><p>第一次远程登录一个新的主机时一般会出现如下提示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host <span class="string">'xxx.com (xx.xx.xx.xx)'</span> can<span class="string">'t be established.</span></span><br><span class="line"><span class="string">RSA key fingerprint is xx:xx...xx:xx.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></table></figure></p><p>输入yes即可。然后可能会出现如下警告，意味着要永久存储该机器的特征信息，不用理睬即可：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: Permanently added ‘xxx.com,xx.xx.xx.xx’ (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure></p><h2 id="known-hosts文件"><a href="#known-hosts文件" class="headerlink" title="known_hosts文件"></a>known_hosts文件</h2><p>当你访问远程主机时，系统会记录远程主机的特征信息，这些信息都存储在<code>known_hosts</code>里面。如果你不小心删掉了的话，也没什么事请，就是下一次进行SSH链接时还会出现第一次登录的提示，按照提示输入yes即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前沿&quot;&gt;&lt;a href=&quot;#前沿&quot; class=&quot;headerlink&quot; title=&quot;前沿&quot;&gt;&lt;/a&gt;前沿&lt;/h1&gt;&lt;p&gt;本文记录了我配置同机多SSH时候的全过程。&lt;br&gt;本文是在Ubuntu 16.04 LTS下配置的，如果使用其他操作系统请自行查找对应命令或
      
    
    </summary>
    
      <category term="Config" scheme="https://lrscy.github.io/categories/Config/"/>
    
    
      <category term="Ubuntu" scheme="https://lrscy.github.io/tags/Ubuntu/"/>
    
      <category term="SSH" scheme="https://lrscy.github.io/tags/SSH/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 16.04下Ruby基础配置</title>
    <link href="https://lrscy.github.io/2017/05/01/Ubuntu-Ruby-base-config/"/>
    <id>https://lrscy.github.io/2017/05/01/Ubuntu-Ruby-base-config/</id>
    <published>2017-04-30T16:00:00.000Z</published>
    <updated>2018-02-02T08:58:40.756Z</updated>
    
    <content type="html"><![CDATA[<p>Note: 本文内容节选复述了<a href="https://ruby-china.org/wiki/install_ruby_guide" target="_blank" rel="noopener">Ruby-China</a>中的教程中的内容，其中有一两步和原版有出入（我踩到的坑）。如果需要看原版内容请点击上述链接。</p><p>本文是在Ubuntu 16.04 LTS环境下配置的，如果使用其他操作系统请自行查找对应命令或解决方案。</p><p>以下代码区域，带有$打头的表示需要在控制台（终端或称命令行）下面执行（不包括$符号）</p><p>由于ubuntu自带的ruby版本太老，所以需要从下列途径更新。</p><h1 id="安装系统需要的包"><a href="#安装系统需要的包" class="headerlink" title="安装系统需要的包"></a>安装系统需要的包</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install curl</span><br><span class="line">$ ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure><p>其中curl是一种下载工具，在后续操作中需要用到。</p><h1 id="安装RVM"><a href="#安装RVM" class="headerlink" title="安装RVM"></a>安装RVM</h1><p>RVM安装只需输入以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3</span><br><span class="line">$ curl -sSL https://get.rvm.io | bash -s stable</span><br><span class="line"><span class="comment"># 如果上面的连接失败，可以尝试: </span></span><br><span class="line">$ curl -L https://raw.githubusercontent.com/wayneeseguin/rvm/master/binscripts/rvm-installer | bash -s stable</span><br></pre></td></tr></table></figure></p><p>如果其中某些命令出现权限不足提醒，则在前面添加sudo再执行即可。</p><p>接下来载入RVM环境<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> ~/.rvm/scripts/rvm</span><br></pre></td></tr></table></figure></p><p>接下来有一点和教程中不太一样（我踩到的坑）。打开<code>~/.bash_profile</code>文件你可能发现如下一行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ -s <span class="string">"<span class="variable">$HOME</span>/.rvm/scripts/rvm"</span> ]] &amp;&amp; <span class="built_in">source</span> <span class="string">"<span class="variable">$HOME</span>/.rvm/scripts/rvm"</span> <span class="comment"># Load RVM into a shell session *as a function*</span></span><br></pre></td></tr></table></figure></p><p>原文中说“新开的终端就不想要这么做了，会自动重新载入的”正因为RVM安装程序在<code>.bash_profile</code>中添加了这么一行。然而你可能发现现实很残酷，新开的终端并没有载入rvm环境。此时你需要在家目录（<code>～</code>）下的.bashrc文件中的末尾添加如下几行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add RVM to PATH for scripting. Make sure this is the last PATH variable change.</span></span><br><span class="line">[[ -s <span class="string">"<span class="variable">$HOME</span>/.rvm/scripts/rvm"</span> ]] &amp;&amp; <span class="built_in">source</span> <span class="string">"<span class="variable">$HOME</span>/.rvm/scripts/rvm"</span></span><br></pre></td></tr></table></figure></p><p>其实也就是复制到.bashrc中而已。然后重启终端即可，如果还不行那么注销重新登录即可，如果还不行请重启机器。</p><p>然后修改RVM下的Ruby源，到Ruby China的镜像：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"ruby_url=https://cache.ruby-china.org/pub/ruby"</span> &gt; ~/.rvm/user/db</span><br></pre></td></tr></table></figure></p><p>检查下是否安装正确<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm -v</span><br></pre></td></tr></table></figure></p><h1 id="用RVM按转Ruby环境"><a href="#用RVM按转Ruby环境" class="headerlink" title="用RVM按转Ruby环境"></a>用RVM按转Ruby环境</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rvm requirements</span><br><span class="line">$ rvm instll 2.4.0</span><br></pre></td></tr></table></figure><p>这里的版本号（2.4.0）可以通过下属命令查看并可修改：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm list</span><br></pre></td></tr></table></figure></p><h1 id="设置Ruby版本"><a href="#设置Ruby版本" class="headerlink" title="设置Ruby版本"></a>设置Ruby版本</h1><p>RVM 安装好后，需要执行下述命令将指定版本设为系统默认版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm use 2.4.0 --default</span><br></pre></td></tr></table></figure></p><p>这个时候你可以测试是否正确<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ruby -v</span><br><span class="line">$ gem -v</span><br></pre></td></tr></table></figure></p><p>这里你可以替换原有的gem源到Ruby China的源或者淘宝源，分别是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/</span><br><span class="line">$ gem sources --add https://ruby.taobao.org/ --remove https://rubygems.org/</span><br></pre></td></tr></table></figure></p><p>可以通过下属命令查看gem源：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem sources -l</span><br></pre></td></tr></table></figure></p><p>接下来安装Bundler<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install bundler</span><br></pre></td></tr></table></figure></p><h1 id="设置Rails环境"><a href="#设置Rails环境" class="headerlink" title="设置Rails环境"></a>设置Rails环境</h1><p>输入以下命令就可以轻松安装上Rails了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install rails</span><br></pre></td></tr></table></figure></p><p>测试是否安装正确<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rails -v</span><br></pre></td></tr></table></figure></p><p>至此，Ruby基础安装教程到此结束喵～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Note: 本文内容节选复述了&lt;a href=&quot;https://ruby-china.org/wiki/install_ruby_guide&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ruby-China&lt;/a&gt;中的教程中的内容，其中有一两步和原版有出
      
    
    </summary>
    
      <category term="Config" scheme="https://lrscy.github.io/categories/Config/"/>
    
    
      <category term="Ubuntu" scheme="https://lrscy.github.io/tags/Ubuntu/"/>
    
      <category term="Ruby" scheme="https://lrscy.github.io/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 16.04下Github配置</title>
    <link href="https://lrscy.github.io/2017/05/01/Ubuntu-Github-config/"/>
    <id>https://lrscy.github.io/2017/05/01/Ubuntu-Github-config/</id>
    <published>2017-04-30T16:00:00.000Z</published>
    <updated>2018-02-02T08:56:46.455Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文记录了我配置Github时候的全过程。</p><p>本文是在Ubuntu 16.04LTS下配置的，如果使用其他操作系统请自行查找对应命令或解决方案。</p><p>以下代码区域，带有<code>$</code>打头的表示需要在控制台（终端或称命令行）下面执行（不包括<code>$</code>符号）</p><h1 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h1><p>Ubuntu下需要安装git，输入命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git</span><br></pre></td></tr></table></figure></p><h1 id="Github账户注册"><a href="#Github账户注册" class="headerlink" title="Github账户注册"></a>Github账户注册</h1><p>你需要一个Github的账户才能使用github.io服务。所以去<code>github.com</code>点击右上角的<code>Sign Up</code>注册即可。</p><h1 id="SSH配置"><a href="#SSH配置" class="headerlink" title="SSH配置"></a>SSH配置</h1><p>我们需要使用ssh来和github上的远程仓库进行通信，所以需要检查和配置ssh。</p><p>首先需要检查电脑上现有的ssh key:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh</span><br></pre></td></tr></table></figure></p><p>如果提示：<code>No such file or dictionary</code> 则说明你是第一次使用git。</p><p>如果你是第一次使用git，那么你需要做如下工作。否则可以跳过此节。</p><p>生成新的SSH KEY:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"youraddress@youremail.com"</span></span><br></pre></td></tr></table></figure></p><p>这里有几点需要注意的：</p><ol><li><code>-C</code>中的C是大写字母</li><li><code>youraddress@youremail.com</code>是你Github的注册邮箱<br>其余的一路回车就能完成了。其中.pub是公钥，需要给到远程主机上，这点我们下一节再讲。</li></ol><p>如果你需要连接多ssh终端，详见「<a href="/2017/05/02/Ubuntu-SSH-config">Ubuntu16.04下(多)SSH配置</a>」。</p><h1 id="Github配置"><a href="#Github配置" class="headerlink" title="Github配置"></a>Github配置</h1><p>仅仅本地配置好了是不够的，你需要让你的github账户认识你。所以你需要按照以下步骤操作：</p><ol><li>去登录github账户，在右上角点击头像找到Settings</li><li>点进去后点击左侧栏中的SSH and GPG keys</li><li>点击右侧New SSH key</li><li>随意输入个能带便当前机器的名字，并把本地.ssh目录下生成的关于github的.pub文件拷贝进来</li><li>保存即可</li></ol><h1 id="Github连接检查"><a href="#Github连接检查" class="headerlink" title="Github连接检查"></a>Github连接检查</h1><p>当一切配置妥当后，在终端中输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><p>如果你是第一次输入此命令，可能遇到如下提示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host <span class="string">'github.com (207.97.227.239)'</span> can<span class="string">'t be established.</span></span><br><span class="line"><span class="string">RSA key fingerprint is xx:xx...xx:xx.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></table></figure></p><p>此时输入yes即可，然后会出现：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi xxx! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure></p><p>此时表明你的github配置完成了</p><h1 id="本地个人信息配置"><a href="#本地个人信息配置" class="headerlink" title="本地个人信息配置"></a>本地个人信息配置</h1><p>此时你已经可以通过SSH连接到Github了，但是还有一些个人信息需要完善才能够和Github愉快的通信。</p><p>Git会依据本地设定的用户名和邮箱向远程主机提交更改，Github也是依据这些信息进行权限管理的。如果你当前只使用一个Github帐号，那么你需要以下两个命令来完善本地个人信息设定：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"your github name"</span></span><br><span class="line">$ git config --global user.email <span class="string">"youraddress@youremail.com"</span></span><br></pre></td></tr></table></figure></p><p>上述命令中your github name是你的github用户名，youraddress@youremail.com是你github的注册邮箱。</p><p>如果你需要配置多Github账户，则需要用如下命令将–global所设置的参数撤销掉：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global <span class="built_in">unset</span> user.name</span><br><span class="line">$ git config --global <span class="built_in">unset</span> user.email</span><br></pre></td></tr></table></figure></p><p>在每个git根目录下自行建立个人信息，命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.name <span class="string">"your github name"</span></span><br><span class="line">$ git config user.email <span class="string">"youraddress@youremail.com"</span></span><br></pre></td></tr></table></figure></p><p>上述命令中<code>your github name</code>是你的github用户名，<code>youraddress@youremail.com</code>是你github的注册邮箱。</p><p>至此，Github配置已全部完成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文记录了我配置Github时候的全过程。&lt;/p&gt;
&lt;p&gt;本文是在Ubuntu 16.04LTS下配置的，如果使用其他操作系统请自行查找对应
      
    
    </summary>
    
      <category term="Config" scheme="https://lrscy.github.io/categories/Config/"/>
    
    
      <category term="Ubuntu" scheme="https://lrscy.github.io/tags/Ubuntu/"/>
    
      <category term="SSH" scheme="https://lrscy.github.io/tags/SSH/"/>
    
      <category term="Github" scheme="https://lrscy.github.io/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 16.04下从零起步搭建配置github.io博客——Jekyll</title>
    <link href="https://lrscy.github.io/2017/04/30/Ubuntu-Github-io-config-Jekyll/"/>
    <id>https://lrscy.github.io/2017/04/30/Ubuntu-Github-io-config-Jekyll/</id>
    <published>2017-04-29T16:00:00.000Z</published>
    <updated>2018-02-02T08:57:53.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文旨在将我配置github.io博客全过程展现出来，帮助从零起步的小白们一步一步的配置属于自己的github.io博客。如果过程正哪一步骤错了，请各位大佬指出，谢谢～</p><p>小白的入门门槛：</p><p>需要耐心，耐心，耐心<br>碰到问题自主去学习和在网上寻找答案</p><p>本文是在Ubuntu 16.04 LTS环境下配置的，如果使用其他操作系统请自行查找对应命令或解决方案。</p><p>以下代码区域，带有<code>$</code>打头的表示需要在控制台（终端或称命令行）下面执行（不包括<code>$</code>符号）</p><p>本文几乎所有命令都可以直接拷到控制台（终端或称命令行）内直接执行而不用理解其具体含义（除非特殊表明需要修改），但是强烈不建议这么做！！！</p><p>我是基于Jekyll模板搭建的博客，所以不会讲如何从零手敲出一个博客样式出来，但会比较详细的讲模板中哪里需要修改。</p><h1 id="基础环境搭建"><a href="#基础环境搭建" class="headerlink" title="基础环境搭建"></a>基础环境搭建</h1><h2 id="Git-Github-SSH配置"><a href="#Git-Github-SSH配置" class="headerlink" title="Git/Github/SSH配置"></a>Git/Github/SSH配置</h2><p>详见我的博客「<a href="/2017/05/01/Ubuntu-Github-config">Ubuntu16.04下Gtihub配置</a>」。</p><h2 id="本地Jekyll环境配置"><a href="#本地Jekyll环境配置" class="headerlink" title="本地Jekyll环境配置"></a>本地Jekyll环境配置</h2><p>因为github.io博客是基于Jekyll模板生成的，所以需要了解下Jekyll模板。其实本地不配置Jekyll也是可以的，不过后果就是无法进行本地预览。提交到Github上平均需要10分钟才能看到更改结果，所以我是建议本地配置下Jekyll的。</p><h3 id="Ruby安装配置"><a href="#Ruby安装配置" class="headerlink" title="Ruby安装配置"></a>Ruby安装配置</h3><p>Jekyll是基于ruby的，所以要安装Jekyll还需要安装ruby, gem等。不过不要担心，我已经把雷都踩过了，你只需要跟着我一步步走就好。不过，我们不需要把Rails环境配上，因为我们暂时用不到。</p><p>详见我的博客「<a href="/2017/05/01/Ubuntu-Ruby-base-config">Ubuntu16.04下Ruby基础配置</a>」。</p><h3 id="Jekyll安装配置"><a href="#Jekyll安装配置" class="headerlink" title="Jekyll安装配置"></a>Jekyll安装配置</h3><p>由于上一步已经安装好了Ruby和gem了，所以只需要下面一条命令就可以安上Jekyll：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install jekyll</span><br></pre></td></tr></table></figure></p><p>没了，嗯～</p><p>真的没骗你～喵～</p><p>至此基础环境搭建也就完成了。</p><h1 id="Jekyll目录介绍"><a href="#Jekyll目录介绍" class="headerlink" title="Jekyll目录介绍"></a>Jekyll目录介绍</h1><p>我会对Jekyll目录进行一个简单粗略的介绍，让你知道每个目录大概都是做什么的，便于你以后查找需要修改的文件的位置。</p><p>Note: 我的博客是基于其他作者些的Jekyll主题改的，所以以下部分所述“不需要修改”皆出于此出发点。对于有前端基础的同学请自行忽略。</p><p>下面是目录树：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">blog</span><br><span class="line">  _includes</span><br><span class="line">    footer.html</span><br><span class="line">    head.html</span><br><span class="line">    header.html</span><br><span class="line">  _layouts</span><br><span class="line">    default.html</span><br><span class="line">    page.html</span><br><span class="line">    post.html</span><br><span class="line">  _posts</span><br><span class="line">    2017-04-30-Hello.md</span><br><span class="line">  _sass</span><br><span class="line">  _site</span><br><span class="line">  css</span><br><span class="line">    main.scss</span><br><span class="line">  .gitignore</span><br><span class="line">  .sass-cache</span><br><span class="line">  _config.yml</span><br><span class="line">  about.md</span><br><span class="line">  feed.xml</span><br><span class="line">  index.html</span><br></pre></td></tr></table></figure></p><h2 id="include"><a href="#include" class="headerlink" title="_include"></a>_include</h2><p>这里都是网页模块文件，用来加载到你的布局或文章中。以后可能需要修改部分内容。<br>可以在其他文件中采用如下方法调用该文件夹内文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; % include file %&#125;</span><br></pre></td></tr></table></figure></p><p>Note: 调用时候把{和%之间的空格去掉</p><h2 id="layouts"><a href="#layouts" class="headerlink" title="_layouts"></a>_layouts</h2><p>存放网页模板。每个网页只需要关注自己的内容。也基本上不用修改。</p><h2 id="posts"><a href="#posts" class="headerlink" title="_posts"></a>_posts</h2><p>这里就是存放我们博文的地方了。文件名称非常非常关键，必须使用统一的格式：<code>YEAR-MONTH-DAY-TITLE.md</code>且中间不能有空格。例如：<code>2017-04-30-Hello.md</code>。不是此格式的博文不会被解析也不会在网站中显示。</p><h2 id="sass"><a href="#sass" class="headerlink" title="_sass"></a>_sass</h2><p>存放网站用到的sass文件。基本上你不用管这里面做了些什么。</p><h2 id="site"><a href="#site" class="headerlink" title="_site"></a>_site</h2><p>在Jekyll解析完成这些文件后，会将最终的静态网站源代码默认的放在这个文件夹下来保存。这个文件夹最好添加进.gitignore文件中（这个问题我们后面再说）。</p><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><p>存放网页样式文件。基本上也不用管。</p><h2 id="sass-cache"><a href="#sass-cache" class="headerlink" title=".sass-cache"></a>.sass-cache</h2><p>sass的编译缓存文件。基本上你不用管这里面都是什么。</p><h2 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h2><p>最重要的配置文件，这里面决定了Jekyll如何解析网站源代码。官方有给出配置文件详细信息，详情请见<a href="http://jekyll.com.cn/docs/configuration/" target="_blank" rel="noopener">这里</a>。</p><h2 id="plugins"><a href="#plugins" class="headerlink" title="_plugins"></a>_plugins</h2><p>你可能需要这个文件夹也可能不需要，按需建立此文件夹。这里用来存放Jekyll插件。</p><h1 id="正式开始搭建博客"><a href="#正式开始搭建博客" class="headerlink" title="正式开始搭建博客"></a>正式开始搭建博客</h1><p>终于开始搭博客了喵～</p><h2 id="Github仓库建立"><a href="#Github仓库建立" class="headerlink" title="Github仓库建立"></a>Github仓库建立</h2><p>本节是在复述<a href="https://pages.github.com/" target="_blank" rel="noopener">官方教程</a>中的内容。</p><h3 id="建立一个仓库"><a href="#建立一个仓库" class="headerlink" title="建立一个仓库"></a>建立一个仓库</h3><p>你需要在你的Github中建立一个新的仓库，名字必须是<code>{your github username}.github.io</code>，否则Github不会将其认为是Github博客。</p><h3 id="克隆到本地"><a href="#克隆到本地" class="headerlink" title="克隆到本地"></a>克隆到本地</h3><p>采用下述命令进行复制<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/username/username.github.io</span><br></pre></td></tr></table></figure></p><p>这里的username是你的github用户名</p><p>至此，Github部分完结</p><h2 id="Jekyll模板"><a href="#Jekyll模板" class="headerlink" title="Jekyll模板"></a>Jekyll模板</h2><p>我的博客是基于Pithy主题建立的。Jekyll模板可以从Jekyll Theme上或大佬们的Github上下载。下载解压后直接将所有文件都拷贝到自己刚克隆下来的文件夹下即可。</p><h3 id="config-yml-1"><a href="#config-yml-1" class="headerlink" title="_config.yml"></a>_config.yml</h3><p>解压后唯一需要修改的部分，修改其中所有你认识的英文，如果没有可以填的空着就好。</p><p>接下来你需要做的就是将其push到远程仓库里。如果你不熟悉Git操作命令，我强烈建议你去看下<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的Git教程</a>。</p><h2 id="添加-gitignore文件"><a href="#添加-gitignore文件" class="headerlink" title="添加.gitignore文件"></a>添加.gitignore文件</h2><p>上文介绍jekyll结构的时候说了句_site要加入.gitignore文件中。.gitignore文件是git上传时要过滤掉的文件。依据自己需求改下就可以了。我目前的.gitignore文件如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_site/*</span><br><span class="line">.sass-cache</span><br><span class="line">.jekyll-metadata</span><br><span class="line">.swp</span><br></pre></td></tr></table></figure></p><p>搭完了，嗯，你没看错，搭完了喵～</p><h2 id="添加Mathjax支持"><a href="#添加Mathjax支持" class="headerlink" title="添加Mathjax支持"></a>添加Mathjax支持</h2><p>作为一个技术小白，就算再小白也有需要用到数学公式的时候。这时mathjax能满足你的大部分需求。Mathjax配置很简单，过程如下：</p><p>在<code>_include/head.html</code>中添加以下代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-mathjax-config"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  MathJax.Hub.Config(&#123;</span></span><br><span class="line"><span class="undefined">    TeX: &#123; equationNumbers: &#123; autoNumber: "AMS" &#125; &#125;,</span></span><br><span class="line"><span class="undefined">    tex2jax: &#123;</span></span><br><span class="line"><span class="undefined">      inlineMath: [ ['$','$'], ['\\(', '\\)'] ],</span></span><br><span class="line"><span class="undefined">      displayMath: [ ['$$','$$'] ],</span></span><br><span class="line"><span class="undefined">      processEscapes: true,</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>最后一行那里的src，有些博客包括官方教程些的都是<code>http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML</code>，然而在https下此网址被认为是不安全的而一些浏览器被屏蔽了（比如Chrome），所以需要换成这个网址。</p><p>然后你需要检查下<code>_config.yml</code>中是否有如下一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">markdown: kramdown</span><br></pre></td></tr></table></figure></p><p>如果没有添加上即可。这是在指定markdown的解释器，如果你想换成其他的也可以。</p><p>至此，Mathjax配置完成了。用在行内用<code>$</code>来包裹latex公式，行间公式需要用<code>$$</code>包裹住。例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 第一种</span><br><span class="line">blabla$x$blabla</span><br><span class="line"># 第二种</span><br><span class="line">$$</span><br><span class="line">P(y|x)</span><br><span class="line">$$</span><br></pre></td></tr></table></figure></p><h2 id="添加代码高亮"><a href="#添加代码高亮" class="headerlink" title="添加代码高亮"></a>添加代码高亮</h2><p>我选择的是Jekyll原生支持的rouge进行代码高亮。只需要在_config.yml中添加一行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">highlighter: rouge</span><br></pre></td></tr></table></figure></p><p>即可高亮代码。</p><h1 id="最后的检测"><a href="#最后的检测" class="headerlink" title="最后的检测"></a>最后的检测</h1><p>现在你已经配好了所有功能，在git仓库的根目录下运行<code>jekyll serve</code>即可以迅速在本地生成博客。通过浏览器访问<code>localhost:4000</code>即可看到成果啦喵～</p><p>最后的最后记得push到你Github的远程仓库中，然后就可以在网页上看到你自己的博客了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文旨在将我配置github.io博客全过程展现出来，帮助从零起步的小白们一步一步的配置属于自己的github.io博客。如果过程正哪一步骤
      
    
    </summary>
    
      <category term="Config" scheme="https://lrscy.github.io/categories/Config/"/>
    
    
      <category term="Ubuntu" scheme="https://lrscy.github.io/tags/Ubuntu/"/>
    
      <category term="Github.io" scheme="https://lrscy.github.io/tags/Github-io/"/>
    
      <category term="Jekyll" scheme="https://lrscy.github.io/tags/Jekyll/"/>
    
  </entry>
  
  <entry>
    <title>「译」GPU神经网络机器翻译导论（第一部分）</title>
    <link href="https://lrscy.github.io/2017/04/29/Trans-Intro-to-NMT-with-GPUs-part1/"/>
    <id>https://lrscy.github.io/2017/04/29/Trans-Intro-to-NMT-with-GPUs-part1/</id>
    <published>2017-04-28T16:00:00.000Z</published>
    <updated>2018-02-03T04:25:59.919Z</updated>
    
    <content type="html"><![CDATA[<p>原文名：<a href="https://devblogs.nvidia.com/parallelforall/introduction-neural-machine-translation-with-gpus/" target="_blank" rel="noopener">Introduction to Neural Machine Translation with GPUs (part 1)</a></p><p>翻译自<a href="https://devblogs.nvidia.com/parallelforall/introduction-neural-machine-translation-with-gpus/" target="_blank" rel="noopener">NVIDIA 深度学习系列</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="theano_logo_179x115.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>「译者注：博文中有些链接指向Google Drive，需要各位同学科学上网查阅资料。」</p><p>注意：这篇是Kyunghyun Cho写的神经网络机器翻译系列中的第一篇。其余的请见第二部分和第三部分。</p><p>神经网络机器翻译是近期被提出的的一个框架，其只基于神经网络。此篇文章是该系列的第一篇文章，我将阐述一个简单的编码-解码模型来构建一个神经网络机器翻译系统「<a href="https://arxiv.org/abs/1406.1078" target="_blank" rel="noopener">Cho et al., 2014</a>; <a href="http://arxiv.org/abs/1409.3215" target="_blank" rel="noopener">Sutskever et al., 2014</a>; <a href="https://scholar.google.com/citations?view_op=view_citation&amp;hl=en&amp;user=LFyg0tAAAAAJ&amp;citation_for_view=LFyg0tAAAAAJ:d1gkVwhDpl0C" target="_blank" rel="noopener">Kalchbrenner and Blunsom, 2013</a>」。后面的文章我将阐述如何将注意力机制融入简单的编码-解码模型中「Bahdanau et al., 2015」，并且形成好的英法、英德、英土和英中翻译模型「<a href="http://arxiv.org/abs/1503.03535" target="_blank" rel="noopener">Gulcehre et al., 2015</a>; <a href="https://arxiv.org/abs/1412.2007" target="_blank" rel="noopener">Jean et al., 2015</a>」。此外，我将介绍一些近期最新的进展——将此神经网络机器翻译框架应用于描述图像和视频的。</p><h1 id="统计机器翻译"><a href="#统计机器翻译" class="headerlink" title="统计机器翻译"></a>统计机器翻译</h1><p>首先，我们简单的阐述下机器翻译。事实上，机器翻译是个统称。我们希望机器将一种语言（我们称之为源语言）翻译成另一种语言（我们称之为目标语言）。（尽管理想情况下，机器应该能够将一整篇文档从一种语言翻译到另一种语言，但是我们在此篇博客中专注于句子级别的机器翻译。）</p><p>我们有许多方式去构建一台能够翻译语言的机器。例如，我们可以请教一个同时会两门语言的的人为我们构建一套翻译规则来将源语言正确的翻译成目标语言。但是这不是一个好的解决方案，联想下我们自己，我们可能都无法完整的构建出我们母语的语法规则，更别提构建两个语言规则之间的对应了。写一套详尽的翻译规则将源语言翻译成目标语言更是痴心妄想。因此，在此篇博文中，我们将专注于利用统计的方法，通过大量的文本语料库来提取这些隐式和显式的规则。</p><p>这种通过统计方法进行机器翻译的方法被成为统计机器翻译。虽然最终目标是相同的（建立一个能将一个句子从一种语言翻译到另一种语言的机器），但是我们让机器从数据中学习如何翻译而非学习如何构建规则（如图1的图解）。此学习是基于统计的方法，每个学习过机器学习的人都应该很熟悉此方法。事实上，统计机器翻译只是机器学习的一种特定的应用——寻找一种从源语言到相关目标语言的对应关系。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="Figure_1-624x224.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><div align="center">图1. 统计机器翻译</div><p>机器翻译的一个重要的特征是翻译函数并非像其他机器学习应用一样是一对一的或多对一的（例如分类应用的函数就是多对一的），而是一对多的，也就是说一个源句子可能有多个可能的翻译结果。正因如此，模型的方法不是个确定性函数而是一个目标句子$y$对$x$的条件概率$p(y|x)$。条件概率能够对于多个分离度良好的结构或句子分配同等的高概率，这就使得源语言和目标语言的一对多关系得以成立。</p><p>现在，我们假设你将建立一个统计机器翻译系统并且要将英语翻译成法语。第一步且可能是最重要的一步是收集平行语料。我们用$x^n$和$y^n$来分别表示源语句和对应的翻译语句。上标$n$代表这是第$n$对语句（通常我们需要成千上万对语句才能训练出一个好的翻译模型）。我将用$D=(x^1,y^1),…,(x^N,y^N)$来表示数据中有$N$对语句对。</p><p>我们从哪里能得到这些训练语句对呢？对于机器翻译中广泛使用的语言，你可能想要查看统计机器翻译研讨会 (EMNLP)或者国际语言翻译研讨会 (IWSLT)。</p><p>在有了训练集$D=(x^1,y^1),…,(x^N,y^N)$后，我们能够通过观察这个模型在训练集$D$上的表现给这个模型打分。这分数（我将称之为模型的对数似然）是该模型对每一对$(x^n,y^n)$的对数似然的平均值。利用机器翻译模型的概率解释，模型在每一对上的对数似然只是模型给这一对语料$log⁡(y^n|x^n,θ)$评估的对数概率有多高。然后，整个模型的在训练集上的打分如下：</p><p>$$ \mathcal{L}(\theta, D) = \sum_{(x^n, y^n) \in D} \log p(y^n|x^n, \theta) $$</p><p>如果对数似然值$\mathcal{L}$很低，说明该模型没有分配给正确翻译句对足够的概率，也意味着该模型将部分概率分配给了错误的翻译。所以，我们希望找到一种模型的结构或者参数$θ$来最大化对数似然或得分。</p><p>在机器学习中，这被称为最大似然估计。除此之外我们还有一个更重要的问题：我们如何建立模型$p(y|x,θ)$？</p><h1 id="统计机器翻译简述"><a href="#统计机器翻译简述" class="headerlink" title="统计机器翻译简述"></a>统计机器翻译简述</h1><p>IBM T.J. 沃森研究中心「Brown et al., 1993等其他参考文献」在20多年前就已经提出并回答了如何建立条件分布模型。从那时起，统计机器翻译(SMT)的核心就是一个线性对数模型，我们用有许多特征的线性组合近似了$p(y|x)$的对数：</p><p>$$ \log p(y|x) \approx \log p(y|x, \theta) = \sum_i \theta_i f_i(x, y) + C(\theta), $$</p><p>其中$C$是归一化常数。在这种情况下，很大一部分研究工作是要找到一组很好的特征函数f_i，并且有一本书已经详尽描述了关于其的所有细节「<a href="http://www.statmt.org/book/" target="_blank" rel="noopener">Koehn</a>」。</p><p>在这种统计机器翻译方法中，通常来说机器学习需要做的只是寻找到一组能够平衡不同特征的系数θ_i，或者从对数线性模型「<a href="http://www.google.com/url?q=http%3A%2F%2Fwww.sciencedirect.com%2Fscience%2Farticle%2Fpii%2FS0885230806000325&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNGsoe0L0ioiBqvl9tmmFRVPNozyNQ" target="_blank" rel="noopener">Schwenk, 2007</a>」中筛选或重新排序一组可能的翻译。更具体来所，神经网络已经被用作组成特征函数功能的一部分，也可以用来重新排序所谓的最佳可能翻译的列表，就像图2中中间和右边部分。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="smt_nmt-624x351.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><div align="center">图2. 图解NMT，SMT+神经网络重新排序和SMT-NN。从「Bahadanau et al., 2015」在ICLR2015中的幻灯片中截取</div><p>另一方面，在此篇博客中，我将专注于最近提出一种称为神经网络机器翻译的方法。其中机器学习，特别是神经网络，拥有更多甚至全部的控制权。正如图2中左边部分所展示的。</p><h1 id="神经网络机器翻译"><a href="#神经网络机器翻译" class="headerlink" title="神经网络机器翻译"></a>神经网络机器翻译</h1><p>就像普通的<a href="https://developer.nvidia.com/deep-learning" target="_blank" rel="noopener">深度学习</a>一样，神经网络机器翻译(NMT)不依赖于已经提前设计好的方法。（通过提前设计好的方法，也就是说那些没有学习的功能。）相比而言，NMT设计的目标是设计一个完全可训练的模型，其每一部分都是基于语料库进行调整，以最优化其翻译表现。</p><p>一个完全可训练的NMT模型$\mathcal{M}$从尽可能的地道的表述源语言语句开始训练，到生成尽可能地道的目标语言语句停止。目前，我们来考虑一个词序列视作作一个句子的最原始的表示。（虽然对于大多数语言来说这并不合理，但是在尽可能的保证一般性的前提下，我会将词作为一个语言的最小的单位。）每一个序列中的词都被它在字典中的索引数字代替。例如，在基于词频率的英语词典中，第一个出现的词会被表示为整数1。我将用$X=(x_1,x_2, \cdots, x_T)$来表示源句子，用$Y=(y_1, y_2, \cdots, y_{T’})$来表示目标句子。</p><p>给出源句子$X=(x_1,x_2, \cdots, x_T)$的词索引，NMT模型$\mathcal{M}$会计算$Y=(y_1, y_2, \cdots, y_{T’})$的条件概率。接下来，我将阐述我们如何来建立一个神经网络来近似条件概率的条件概率。接下来，我将阐述我们如何来建立一个神经网络来近似条件概率$p(Y|X)$。</p><h1 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h1><p>机器翻译的一个重要的特征，或是说基于自然语言的任何任务，是处理可变长度输入$X=(x_1,x_2, \cdots, x_T)$和可变长度输出$Y=(y_1, y_2, \cdots, y_{T’})$。换句话说，$T$和$T’$不固定。</p><p>为了处理这些可变长度的输入和输出，我们需要用到循环神经网络（RNN）。目前广泛应用的前馈神经网络（比如卷积神经网络）除了网络自身的参数外不保留中间状态。无论何时，一个样例进入前馈神经网络，无论网络内部参数还是隐藏层的激活都是重新计算的而不受前一个样本的状态结果的影响。然而RNN在读入一个序列时保存了其内部状态（在当前情况下是词序列），因此能够处理任何长度的输入。</p><p>我接下来将更详细的解释一下RNN。RNN的主要的思想是通过使用递归将输入的序列压缩成一个固定维度的向量。假设在第$t$步我们有一个向量$h_{t-1}$保存了之前所有的符号的状态。RNN将计算出一个新的向量（或称为内部状态），$h_t$通过下式压缩了之前所有符号$\left(x_1, x_2, \dots, x_{t-1} \right)$包括新的符号$x_t$：</p><p>$$ h_t = \phi_{\theta}(x_t, h_{t-1}) $$</p><p>其中$\phi_{\theta}$是由$\theta$参数化的一个函数，以新符号$x_t$和保存了前$(t−1)$个符号的历史状态$h_{t-1}$作为输入。最开始，我们可以放心的假设$h_0$是一个全零向量。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="Figure_3-624x208.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><div align="center">图3. 图解不同类型的循环神经网络。摘自「<a href="http://arxiv.org/abs/1312.6026" target="_blank" rel="noopener">Pascanu et al., 2014</a>」</div><p>递归激活函数$\phi$通常被实现为一个非线性函数套着一个放射变换：</p><p>$$ h_t=\tanh(Wx_t + Uh_{t-1} + b) $$</p><p>在这个等式中，参数包括输入权重矩阵$W$，循环权重矩阵$U$和一个偏差向量$b$。我必须强调这不是唯一的实现方案，现在依旧有很多的机会来设计新的循环激活函数。见图三的一些例子「<a href="http://arxiv.org/abs/1312.6026" target="_blank" rel="noopener">Pascanu et al., 2014</a>」。</p><p>这种简单的RNN可以轻易的由<a href="http://www.google.com/url?q=http%3A%2F%2Fdeeplearning.net%2Fsoftware%2Ftheano%2F&amp;sa=D&amp;sntz=1&amp;usg=AFQjCNFJoBcoA4NcY2Q-YzLHUW1Ho-Wexw" target="_blank" rel="noopener">Theano</a>来实现，且Theano可以让你的RNN程序在CPU和GPU下透明的运行。详见<a href="http://deeplearning.net/tutorial/rnnslu.html#rnnslu" target="_blank" rel="noopener">循环神经网络实现词向量</a>；注意，整个RNN代码总共<a href="https://github.com/mesnilgr/is13/blob/master/rnn/elman.py#L38-L45" target="_blank" rel="noopener">不超过10行</a>！</p><p>最近，研究发现用更复杂的激活函数来训练循环神经网络有更好的效果且更加容易，比如LSTM「<a href="http://www.mitpressjournals.org/doi/abs/10.1162/neco.1997.9.8.1735?journalCode=neco&amp;" target="_blank" rel="noopener">Hochreiter and Schmidhuber, 1997</a>」和GRU「<a href="https://arxiv.org/abs/1406.1078" target="_blank" rel="noopener">Cho et al., 2014</a>」。</p><p>$$<br>\begin{align}<br>r_t &amp;= \sigma(W_rx_t + Urh_{t-1} + b_r) \\<br>u_t &amp;= \sigma(W_ux_t + r_t \odot (U_uh_{t-1}) + b_u) \\<br>h_t &amp;= u_t \odot h_{t-1} + (1-u_t) \odot \tanh(Wx_t + r_t \odot (U_uh_{t-1}) + b)<br>\end{align}<br>$$</p><p>正如上述情况下的简单循环激活函数，参数包括了输入矩阵$W$($W_r$和$W_u$)，循环神经矩阵$U$($U_r$和$U_u$)和偏差向量$b$($b_r$和$b_u$)。</p><p>虽然这些单元看起来比简单RNN复杂些，但是由Theano或者其他深度学习框架（比如Torch）实现起来会很简单。例如<a href="http://deeplearning.net/tutorial/lstm.html#lstm" target="_blank" rel="noopener">LSTM网络进行情感分析</a>(<a href="https://github.com/kyunghyuncho/DeepLearningTutorials/blob/master/code/lstm.py#L155-L201" target="_blank" rel="noopener">样例代码</a>)。</p><p>我已经将RNN表述为了一个历史压缩器，但是它也可以用来为一个序列进行概率建模。给一个序列进行概率建模的意思是让机器学习一个模型来计算任意给定序列$X=(x_1, x_2, \cdots, x_T)$的概率$p(X)$。我们如何设计$p(X)$才能让其满足递归的形式呢？</p><p>我们从重新将$p(X)=p(x_1, x_2, \cdots, x_{T})$描述为下式开始：</p><p>$$ p(x_1, x_2, \cdots, x{T})=p(x_1)p(x_2|x_1)p(x_3|x_1, x_2) \cdots p(x_T|x1, \cdots, x_{T-1}) $$</p><p>上述改变基于条件概率公式，$p(X|Y)=\frac{P(X,Y)}{P(Y)}$。从上述改变我们可以看出，我们可以设计出一个递归表达式，例如：</p><p>$$ p(x_1)p(x_2|x_1)p(x_3|x_1, x_2) \cdots p(x_T|x_1, \cdots, x_{T-1}) = \prod_{t=1}^{T}p(x_t|x_{&lt;t}) $$</p><p>现在我们使一个RNN模型$p(x_t|x_{&lt;t})$在每一步t$时进行如下操作：</p><p>$$<br>p(x_t|x_{&lt;t}) = g_{\theta}(h_{t-1}) \\<br>h_{t-1} = \phi_{\theta}(x_{t-1}, h_{t-2})<br>$$</p><p>$g_{\theta}$通过$h_{t-1}$输出基于前$(t-1)$个符号全部历史状态的条件分布概率。换句话说，在每个时刻，RNN试图通过学习输入符号的历史数据预测下一个字符应该是什么。</p><p>RNN有许多有趣的属性和特点值得我用上好几个小时来讲述，但是由于这是个博客，我不得就此停止。自此以后，我将讲述你们开始建立神经网络系统前的所有必备的知识。如果你想对RNN有更多的了解的话，我建议你去阅读下述论文。但是很明显，这些论文也并不能穷尽所有RNN有关的知识。你也可以去看我的关于如何将RNN应用于语言模型的幻灯片。</p><ul><li>Graves, Alex. “Generating sequences with recurrent neural networks.” arXiv preprint arXiv:1308.0850 (2013).</li><li>Pascanu, Razvan et al. “How to construct deep recurrent neural networks.” arXiv preprint arXiv:1312.6026 (2013).</li><li>Boulanger-Lewandowski, Nicolas, Yoshua Bengio, and Pascal Vincent. “Modeling temporal dependencies in high-dimensional sequences: Application to polyphonic music generation and transcription.” arXiv preprint arXiv:1206.6392 (2012).</li><li>Mikolov, Tomas et al. “Recurrent neural network based language model.” INTERSPEECH 2010, 11th Annual Conference of the International Speech Communication Association, Makuhari, Chiba, Japan, September 26-30, 2010 1 Jan. 2010: 1045-1048.</li><li>Hochreiter, Sepp, and Jürgen Schmidhuber. “Long short-term memory.” Neural computation 9.8 (1997): 1735-1780.</li><li>Cho, Kyunghyun et al. “Learning phrase representations using rnn encoder-decoder for statistical machine translation.” arXiv preprint arXiv:1406.1078 (2014).</li><li>Bengio, Yoshua, Patrice Simard, and Paolo Frasconi. “Learning long-term dependencies with gradient descent is difficult.” Neural Networks, IEEE Transactions on 5.2 (1994): 157-166.</li></ul><h1 id="接下来的要讲述的事情"><a href="#接下来的要讲述的事情" class="headerlink" title="接下来的要讲述的事情"></a>接下来的要讲述的事情</h1><p>在这篇博文中，我介绍了机器翻译，描述了统计机器翻译如何解决机器翻译的问题。在讲述统计机器翻译框架时，我讨论了神经网络如何用来提高翻译的整体表现。</p><p>这系列博客的目标是介绍一个新的神经网络机器翻译模型；这篇博文奠定了基础，重点介绍了循环神经网络的两个核心能力：序列总结能力和序列概率建模能力。</p><p>基于这两个特性，在下一篇博客中，我将讲述一个完整的基于循环神经网络的神经网络机器翻译系统。我也会想你展示为什么GPU对于神经网络机器翻译这么重要！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文名：&lt;a href=&quot;https://devblogs.nvidia.com/parallelforall/introduction-neural-machine-translation-with-gpus/&quot; target=&quot;_blank&quot; rel=&quot;noopener
      
    
    </summary>
    
      <category term="NLP" scheme="https://lrscy.github.io/categories/NLP/"/>
    
    
      <category term="Deep Learning" scheme="https://lrscy.github.io/tags/Deep-Learning/"/>
    
      <category term="GPU" scheme="https://lrscy.github.io/tags/GPU/"/>
    
      <category term="NLP" scheme="https://lrscy.github.io/tags/NLP/"/>
    
      <category term="NMT" scheme="https://lrscy.github.io/tags/NMT/"/>
    
      <category term="Theano" scheme="https://lrscy.github.io/tags/Theano/"/>
    
  </entry>
  
</feed>
